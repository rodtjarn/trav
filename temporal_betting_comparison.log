2026-01-11 00:01:58,799 - INFO - Loaded model from temporal_rf_model.pkl
2026-01-11 00:01:58,799 - INFO - Model uses 224 features
2026-01-11 00:01:58,800 - INFO - Fetching calendar for 2026-01-11
2026-01-11 00:01:59,546 - INFO - Found 6 tracks for 2026-01-11
2026-01-11 00:02:00,047 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:02:00,204 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:02:00,704 - INFO - Fetching calendar for 2026-01-09
2026-01-11 00:02:00,867 - INFO - Found 7 tracks for 2026-01-09
2026-01-11 00:02:01,367 - INFO - Fetching calendar for 2026-01-08
2026-01-11 00:02:01,514 - INFO - Found 5 tracks for 2026-01-08
2026-01-11 00:02:02,014 - INFO - Fetching calendar for 2026-01-07
2026-01-11 00:02:02,168 - INFO - Found 5 tracks for 2026-01-07
2026-01-11 00:02:02,668 - INFO - Fetching calendar for 2026-01-06
2026-01-11 00:02:02,831 - INFO - Found 5 tracks for 2026-01-06
2026-01-11 00:02:03,331 - INFO - Fetching calendar for 2026-01-05
2026-01-11 00:02:03,473 - INFO - Found 4 tracks for 2026-01-05
2026-01-11 00:02:03,973 - INFO - Fetching calendar for 2026-01-04
2026-01-11 00:02:04,120 - INFO - Found 5 tracks for 2026-01-04
2026-01-11 00:02:04,620 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:02:04,772 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:02:05,272 - INFO - Fetching calendar for 2026-01-02
2026-01-11 00:02:05,436 - INFO - Found 6 tracks for 2026-01-02
2026-01-11 00:02:05,936 - INFO - Fetching calendar for 2026-01-01
2026-01-11 00:02:06,101 - INFO - Found 6 tracks for 2026-01-01
2026-01-11 00:02:06,601 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:02:06,755 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:02:07,255 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:02:07,418 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:02:07,918 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:02:08,080 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:02:08,581 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:02:08,736 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:02:09,236 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:02:09,395 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:02:09,895 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:02:10,060 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:02:10,561 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:02:10,713 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:02:11,213 - INFO - Fetching calendar for 2025-12-24
2026-01-11 00:02:11,375 - INFO - Found 3 tracks for 2025-12-24
2026-01-11 00:02:11,875 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:02:12,029 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:02:12,530 - INFO - Fetching calendar for 2025-12-22
2026-01-11 00:02:12,794 - INFO - Found 5 tracks for 2025-12-22
2026-01-11 00:02:13,294 - INFO - Fetching calendar for 2025-12-21
2026-01-11 00:02:13,473 - INFO - Found 6 tracks for 2025-12-21
2026-01-11 00:02:13,974 - INFO - Fetching calendar for 2025-12-20
2026-01-11 00:02:14,128 - INFO - Found 6 tracks for 2025-12-20
2026-01-11 00:02:14,628 - INFO - Fetching calendar for 2025-12-19
2026-01-11 00:02:14,822 - INFO - Found 7 tracks for 2025-12-19
2026-01-11 00:02:15,322 - INFO - Fetching calendar for 2025-12-18
2026-01-11 00:02:15,553 - INFO - Found 5 tracks for 2025-12-18
2026-01-11 00:02:16,053 - INFO - Fetching calendar for 2025-12-17
2026-01-11 00:02:16,239 - INFO - Found 5 tracks for 2025-12-17
2026-01-11 00:02:16,739 - INFO - Fetching calendar for 2025-12-16
2026-01-11 00:02:16,896 - INFO - Found 6 tracks for 2025-12-16
2026-01-11 00:02:17,396 - INFO - Fetching calendar for 2025-12-15
2026-01-11 00:02:17,554 - INFO - Found 6 tracks for 2025-12-15
2026-01-11 00:02:18,054 - INFO - Fetching calendar for 2025-12-14
2026-01-11 00:02:18,233 - INFO - Found 6 tracks for 2025-12-14
2026-01-11 00:02:18,733 - INFO - Fetching calendar for 2025-12-13
2026-01-11 00:02:18,928 - INFO - Found 4 tracks for 2025-12-13
2026-01-11 00:02:19,429 - INFO - Fetching calendar for 2025-12-12
2026-01-11 00:02:19,585 - INFO - Found 7 tracks for 2025-12-12
2026-01-11 00:02:20,085 - INFO - Fetching calendar for 2025-12-11
2026-01-11 00:02:20,252 - INFO - Found 6 tracks for 2025-12-11
2026-01-11 00:02:20,752 - INFO - Fetching calendar for 2025-12-10
2026-01-11 00:02:20,898 - INFO - Found 5 tracks for 2025-12-10
2026-01-11 00:02:21,398 - INFO - Fetching calendar for 2025-12-09
2026-01-11 00:02:21,551 - INFO - Found 5 tracks for 2025-12-09
2026-01-11 00:02:22,051 - INFO - Fetching calendar for 2025-12-08
2026-01-11 00:02:22,217 - INFO - Found 6 tracks for 2025-12-08
2026-01-11 00:02:22,717 - INFO - Fetching calendar for 2025-12-07
2026-01-11 00:02:22,870 - INFO - Found 7 tracks for 2025-12-07
2026-01-11 00:02:23,370 - INFO - Fetching calendar for 2025-12-06
2026-01-11 00:02:23,533 - INFO - Found 6 tracks for 2025-12-06
2026-01-11 00:02:24,034 - INFO - Fetching calendar for 2025-12-05
2026-01-11 00:02:24,223 - INFO - Found 7 tracks for 2025-12-05
2026-01-11 00:02:24,723 - INFO - Fetching calendar for 2025-12-04
2026-01-11 00:02:24,884 - INFO - Found 5 tracks for 2025-12-04
2026-01-11 00:02:25,384 - INFO - Fetching calendar for 2025-12-03
2026-01-11 00:02:25,546 - INFO - Found 5 tracks for 2025-12-03
2026-01-11 00:02:26,046 - INFO - Fetching calendar for 2025-12-02
2026-01-11 00:02:26,200 - INFO - Found 7 tracks for 2025-12-02
2026-01-11 00:02:26,700 - INFO - Fetching calendar for 2025-12-01
2026-01-11 00:02:26,871 - INFO - Found 6 tracks for 2025-12-01
2026-01-11 00:02:27,371 - INFO - Fetching calendar for 2025-11-30
2026-01-11 00:02:27,569 - INFO - Found 7 tracks for 2025-11-30
2026-01-11 00:02:28,069 - INFO - Fetching calendar for 2025-11-29
2026-01-11 00:02:28,219 - INFO - Found 5 tracks for 2025-11-29
2026-01-11 00:02:28,720 - INFO - Fetching calendar for 2025-11-28
2026-01-11 00:02:28,884 - INFO - Found 8 tracks for 2025-11-28
2026-01-11 00:02:29,385 - INFO - Fetching calendar for 2025-11-27
2026-01-11 00:02:29,557 - INFO - Found 5 tracks for 2025-11-27
2026-01-11 00:02:30,057 - INFO - Fetching calendar for 2025-11-26
2026-01-11 00:02:30,212 - INFO - Found 5 tracks for 2025-11-26
2026-01-11 00:02:30,712 - INFO - Fetching calendar for 2025-11-25
2026-01-11 00:02:30,882 - INFO - Found 6 tracks for 2025-11-25
2026-01-11 00:02:31,382 - INFO - Fetching calendar for 2025-11-24
2026-01-11 00:02:31,571 - INFO - Found 6 tracks for 2025-11-24
2026-01-11 00:02:32,072 - INFO - Fetching calendar for 2025-11-23
2026-01-11 00:02:32,247 - INFO - Found 8 tracks for 2025-11-23
2026-01-11 00:02:32,748 - INFO - Fetching calendar for 2025-11-22
2026-01-11 00:02:32,928 - INFO - Found 9 tracks for 2025-11-22
2026-01-11 00:02:33,429 - INFO - Fetching calendar for 2025-11-21
2026-01-11 00:02:33,611 - INFO - Found 7 tracks for 2025-11-21
2026-01-11 00:02:34,112 - INFO - Fetching calendar for 2025-11-20
2026-01-11 00:02:34,283 - INFO - Found 7 tracks for 2025-11-20
2026-01-11 00:02:34,784 - INFO - Fetching calendar for 2025-11-19
2026-01-11 00:02:34,943 - INFO - Found 5 tracks for 2025-11-19
2026-01-11 00:02:35,443 - INFO - Fetching calendar for 2025-11-18
2026-01-11 00:02:35,596 - INFO - Found 5 tracks for 2025-11-18
2026-01-11 00:02:36,097 - INFO - Fetching calendar for 2025-11-17
2026-01-11 00:02:36,260 - INFO - Found 6 tracks for 2025-11-17
2026-01-11 00:02:36,760 - INFO - Fetching calendar for 2025-11-16
2026-01-11 00:02:36,918 - INFO - Found 6 tracks for 2025-11-16
2026-01-11 00:02:37,418 - INFO - Fetching calendar for 2025-11-15
2026-01-11 00:02:37,585 - INFO - Found 6 tracks for 2025-11-15
2026-01-11 00:02:38,085 - INFO - Fetching calendar for 2025-11-14
2026-01-11 00:02:38,264 - INFO - Found 8 tracks for 2025-11-14
2026-01-11 00:02:38,764 - INFO - Fetching calendar for 2025-11-13
2026-01-11 00:02:38,933 - INFO - Found 6 tracks for 2025-11-13
2026-01-11 00:02:39,433 - INFO - Fetching calendar for 2025-11-12
2026-01-11 00:02:39,601 - INFO - Found 6 tracks for 2025-11-12
2026-01-11 00:02:40,102 - INFO - Fetching calendar for 2025-11-11
2026-01-11 00:02:40,275 - INFO - Found 5 tracks for 2025-11-11
2026-01-11 00:02:40,776 - INFO - Fetching calendar for 2025-11-10
2026-01-11 00:02:40,946 - INFO - Found 5 tracks for 2025-11-10
2026-01-11 00:02:41,446 - INFO - Fetching calendar for 2025-11-09
2026-01-11 00:02:41,606 - INFO - Found 6 tracks for 2025-11-09
2026-01-11 00:02:42,106 - INFO - Fetching calendar for 2025-11-08
2026-01-11 00:02:42,264 - INFO - Found 8 tracks for 2025-11-08
2026-01-11 00:02:42,765 - INFO - Fetching calendar for 2025-11-07
2026-01-11 00:02:42,929 - INFO - Found 8 tracks for 2025-11-07
2026-01-11 00:02:43,429 - INFO - Fetching calendar for 2025-11-06
2026-01-11 00:02:43,593 - INFO - Found 6 tracks for 2025-11-06
2026-01-11 00:02:44,093 - INFO - Fetching calendar for 2025-11-05
2026-01-11 00:02:44,242 - INFO - Found 5 tracks for 2025-11-05
2026-01-11 00:02:44,743 - INFO - Fetching calendar for 2025-11-04
2026-01-11 00:02:44,910 - INFO - Found 6 tracks for 2025-11-04
2026-01-11 00:02:45,411 - INFO - Fetching calendar for 2025-11-03
2026-01-11 00:02:45,573 - INFO - Found 5 tracks for 2025-11-03
2026-01-11 00:02:46,074 - INFO - Fetching calendar for 2025-11-02
2026-01-11 00:02:46,244 - INFO - Found 8 tracks for 2025-11-02
2026-01-11 00:02:46,744 - INFO - Fetching calendar for 2025-11-01
2026-01-11 00:02:46,896 - INFO - Found 8 tracks for 2025-11-01
2026-01-11 00:02:47,397 - INFO - Fetching calendar for 2025-10-31
2026-01-11 00:02:47,574 - INFO - Found 8 tracks for 2025-10-31
2026-01-11 00:02:48,074 - INFO - Fetching calendar for 2025-10-30
2026-01-11 00:02:48,236 - INFO - Found 7 tracks for 2025-10-30
2026-01-11 00:02:48,736 - INFO - Fetching calendar for 2025-10-29
2026-01-11 00:02:48,914 - INFO - Found 5 tracks for 2025-10-29
2026-01-11 00:02:49,414 - INFO - Fetching calendar for 2025-10-28
2026-01-11 00:02:49,566 - INFO - Found 7 tracks for 2025-10-28
2026-01-11 00:02:50,067 - INFO - Fetching calendar for 2025-10-27
2026-01-11 00:02:50,228 - INFO - Found 5 tracks for 2025-10-27
2026-01-11 00:02:50,728 - INFO - Fetching calendar for 2025-10-26
2026-01-11 00:02:50,895 - INFO - Found 10 tracks for 2025-10-26
2026-01-11 00:02:51,395 - INFO - Fetching calendar for 2025-10-25
2026-01-11 00:02:51,569 - INFO - Found 6 tracks for 2025-10-25
2026-01-11 00:02:52,069 - INFO - Fetching calendar for 2025-10-24
2026-01-11 00:02:52,224 - INFO - Found 7 tracks for 2025-10-24
2026-01-11 00:02:52,725 - INFO - Fetching calendar for 2025-10-23
2026-01-11 00:02:52,881 - INFO - Found 5 tracks for 2025-10-23
2026-01-11 00:02:53,381 - INFO - Fetching calendar for 2025-10-22
2026-01-11 00:02:53,553 - INFO - Found 6 tracks for 2025-10-22
2026-01-11 00:02:54,053 - INFO - Fetching calendar for 2025-10-21
2026-01-11 00:02:54,230 - INFO - Found 5 tracks for 2025-10-21
2026-01-11 00:02:54,730 - INFO - Fetching calendar for 2025-10-20
2026-01-11 00:02:54,919 - INFO - Found 6 tracks for 2025-10-20
2026-01-11 00:02:55,419 - INFO - Fetching calendar for 2025-10-19
2026-01-11 00:02:55,588 - INFO - Found 9 tracks for 2025-10-19
2026-01-11 00:02:56,088 - INFO - Fetching calendar for 2025-10-18
2026-01-11 00:02:56,250 - INFO - Found 5 tracks for 2025-10-18
2026-01-11 00:02:56,751 - INFO - Fetching calendar for 2025-10-17
2026-01-11 00:02:56,941 - INFO - Found 7 tracks for 2025-10-17
2026-01-11 00:02:57,441 - INFO - Fetching calendar for 2025-10-16
2026-01-11 00:02:57,608 - INFO - Found 7 tracks for 2025-10-16
2026-01-11 00:02:58,108 - INFO - Fetching calendar for 2025-10-15
2026-01-11 00:02:58,275 - INFO - Found 6 tracks for 2025-10-15
2026-01-11 00:02:58,775 - INFO - Fetching calendar for 2025-10-14
2026-01-11 00:02:58,934 - INFO - Found 7 tracks for 2025-10-14
2026-01-11 00:02:59,435 - INFO - Fetching V85 races for 2026-01-10
2026-01-11 00:02:59,435 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:01,866 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:01,866 - INFO - Found V85 game: V85_2026-01-10_23_3 with 8 races
2026-01-11 00:03:01,866 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:03:01,866 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:02,010 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:02,510 - INFO - Processing track: Romme
2026-01-11 00:03:03,176 - INFO -   Race 2026-01-10_23_1: 12 starts (results)
2026-01-11 00:03:03,827 - INFO -   Race 2026-01-10_23_2: 11 starts (results)
2026-01-11 00:03:04,490 - INFO -   Race 2026-01-10_23_3: 12 starts (results)
2026-01-11 00:03:05,164 - INFO -   Race 2026-01-10_23_4: 12 starts (results)
2026-01-11 00:03:05,829 - INFO -   Race 2026-01-10_23_5: 12 starts (results)
2026-01-11 00:03:06,494 - INFO -   Race 2026-01-10_23_6: 9 starts (results)
2026-01-11 00:03:07,164 - INFO -   Race 2026-01-10_23_7: 12 starts (results)
2026-01-11 00:03:07,816 - INFO -   Race 2026-01-10_23_8: 12 starts (results)
2026-01-11 00:03:08,479 - INFO -   Race 2026-01-10_23_9: 12 starts (results)
2026-01-11 00:03:09,145 - INFO -   Race 2026-01-10_23_10: 15 starts (results)
2026-01-11 00:03:09,145 - INFO - Processing track: Forus
2026-01-11 00:03:09,795 - INFO -   Race 2026-01-10_81_1: 8 starts (results)
2026-01-11 00:03:10,533 - INFO -   Race 2026-01-10_81_2: 10 starts (results)
2026-01-11 00:03:11,186 - INFO -   Race 2026-01-10_81_3: 6 starts (results)
2026-01-11 00:03:11,848 - INFO -   Race 2026-01-10_81_4: 15 starts (results)
2026-01-11 00:03:12,518 - INFO -   Race 2026-01-10_81_5: 11 starts (results)
2026-01-11 00:03:13,177 - INFO -   Race 2026-01-10_81_6: 14 starts (results)
2026-01-11 00:03:13,826 - INFO -   Race 2026-01-10_81_7: 9 starts (results)
2026-01-11 00:03:14,479 - INFO -   Race 2026-01-10_81_8: 10 starts (results)
2026-01-11 00:03:15,127 - INFO -   Race 2026-01-10_81_9: 12 starts (results)
2026-01-11 00:03:15,127 - INFO - Processing track: Vincennes
2026-01-11 00:03:15,895 - INFO -   Race 2026-01-10_63_1: 14 starts (results)
2026-01-11 00:03:16,578 - INFO -   Race 2026-01-10_63_2: 9 starts (results)
2026-01-11 00:03:17,239 - INFO -   Race 2026-01-10_63_3: 11 starts (results)
2026-01-11 00:03:17,911 - INFO -   Race 2026-01-10_63_4: 14 starts (results)
2026-01-11 00:03:18,587 - INFO -   Race 2026-01-10_63_5: 12 starts (results)
2026-01-11 00:03:19,241 - INFO -   Race 2026-01-10_63_6: 16 starts (results)
2026-01-11 00:03:19,908 - INFO -   Race 2026-01-10_63_7: 10 starts (results)
2026-01-11 00:03:20,560 - INFO -   Race 2026-01-10_63_8: 14 starts (results)
2026-01-11 00:03:21,210 - INFO -   Race 2026-01-10_63_9: 13 starts (results)
2026-01-11 00:03:21,210 - INFO - Processing track: Gulfstream Park
2026-01-11 00:03:21,871 - INFO -   Race 2026-01-10_97_1: 11 starts (results)
2026-01-11 00:03:22,540 - INFO -   Race 2026-01-10_97_2: 9 starts (results)
2026-01-11 00:03:23,193 - INFO -   Race 2026-01-10_97_3: 6 starts (results)
2026-01-11 00:03:23,848 - INFO -   Race 2026-01-10_97_4: 8 starts (results)
2026-01-11 00:03:24,555 - INFO -   Race 2026-01-10_97_5: 7 starts (results)
2026-01-11 00:03:25,207 - INFO -   Race 2026-01-10_97_6: 9 starts (results)
2026-01-11 00:03:25,863 - INFO -   Race 2026-01-10_97_7: 7 starts (results)
2026-01-11 00:03:26,530 - INFO -   Race 2026-01-10_97_8: 9 starts (results)
2026-01-11 00:03:27,211 - INFO -   Race 2026-01-10_97_9: 10 starts (results)
2026-01-11 00:03:27,883 - INFO -   Race 2026-01-10_97_10: 6 starts (results)
2026-01-11 00:03:28,535 - INFO -   Race 2026-01-10_97_11: 11 starts (results)
2026-01-11 00:03:28,539 - INFO - V85 Game: V85_2026-01-10_23_3
2026-01-11 00:03:28,539 - INFO - Loaded 96 horses from 8 V85 races
2026-01-11 00:03:28,539 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:03:28,539 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:03:28,542 - INFO - Added temporal features
2026-01-11 00:03:28,543 - INFO - Added post position features
2026-01-11 00:03:28,544 - INFO - Calculated driver/trainer rates
2026-01-11 00:03:28,545 - INFO - Added speed features
2026-01-11 00:03:28,545 - INFO - Added track importance features
2026-01-11 00:03:28,547 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:03:28,706 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:29,317 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:29,317 - INFO - Found V85 game: V85_2026-01-10_23_3 with 8 races
2026-01-11 00:03:29,317 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:03:29,317 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:29,462 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:29,962 - INFO - Processing track: Romme
2026-01-11 00:03:30,621 - INFO -   Race 2026-01-10_23_1: 12 starts (results)
2026-01-11 00:03:31,279 - INFO -   Race 2026-01-10_23_2: 11 starts (results)
2026-01-11 00:03:31,937 - INFO -   Race 2026-01-10_23_3: 12 starts (results)
2026-01-11 00:03:32,599 - INFO -   Race 2026-01-10_23_4: 12 starts (results)
2026-01-11 00:03:33,245 - INFO -   Race 2026-01-10_23_5: 12 starts (results)
2026-01-11 00:03:33,891 - INFO -   Race 2026-01-10_23_6: 9 starts (results)
2026-01-11 00:03:34,557 - INFO -   Race 2026-01-10_23_7: 12 starts (results)
2026-01-11 00:03:35,203 - INFO -   Race 2026-01-10_23_8: 12 starts (results)
2026-01-11 00:03:35,856 - INFO -   Race 2026-01-10_23_9: 12 starts (results)
2026-01-11 00:03:36,561 - INFO -   Race 2026-01-10_23_10: 15 starts (results)
2026-01-11 00:03:36,561 - INFO - Processing track: Forus
2026-01-11 00:03:37,226 - INFO -   Race 2026-01-10_81_1: 8 starts (results)
2026-01-11 00:03:37,872 - INFO -   Race 2026-01-10_81_2: 10 starts (results)
2026-01-11 00:03:38,539 - INFO -   Race 2026-01-10_81_3: 6 starts (results)
2026-01-11 00:03:39,205 - INFO -   Race 2026-01-10_81_4: 15 starts (results)
2026-01-11 00:03:39,871 - INFO -   Race 2026-01-10_81_5: 11 starts (results)
2026-01-11 00:03:40,541 - INFO -   Race 2026-01-10_81_6: 14 starts (results)
2026-01-11 00:03:41,208 - INFO -   Race 2026-01-10_81_7: 9 starts (results)
2026-01-11 00:03:41,872 - INFO -   Race 2026-01-10_81_8: 10 starts (results)
2026-01-11 00:03:42,528 - INFO -   Race 2026-01-10_81_9: 12 starts (results)
2026-01-11 00:03:42,528 - INFO - Processing track: Vincennes
2026-01-11 00:03:43,196 - INFO -   Race 2026-01-10_63_1: 14 starts (results)
2026-01-11 00:03:43,923 - INFO -   Race 2026-01-10_63_2: 9 starts (results)
2026-01-11 00:03:44,577 - INFO -   Race 2026-01-10_63_3: 11 starts (results)
2026-01-11 00:03:45,242 - INFO -   Race 2026-01-10_63_4: 14 starts (results)
2026-01-11 00:03:45,913 - INFO -   Race 2026-01-10_63_5: 12 starts (results)
2026-01-11 00:03:46,575 - INFO -   Race 2026-01-10_63_6: 16 starts (results)
2026-01-11 00:03:47,238 - INFO -   Race 2026-01-10_63_7: 10 starts (results)
2026-01-11 00:03:47,888 - INFO -   Race 2026-01-10_63_8: 14 starts (results)
2026-01-11 00:03:48,614 - INFO -   Race 2026-01-10_63_9: 13 starts (results)
2026-01-11 00:03:48,614 - INFO - Processing track: Gulfstream Park
2026-01-11 00:03:49,272 - INFO -   Race 2026-01-10_97_1: 11 starts (results)
2026-01-11 00:03:49,931 - INFO -   Race 2026-01-10_97_2: 9 starts (results)
2026-01-11 00:03:50,589 - INFO -   Race 2026-01-10_97_3: 6 starts (results)
2026-01-11 00:03:51,253 - INFO -   Race 2026-01-10_97_4: 8 starts (results)
2026-01-11 00:03:51,951 - INFO -   Race 2026-01-10_97_5: 7 starts (results)
2026-01-11 00:03:52,617 - INFO -   Race 2026-01-10_97_6: 9 starts (results)
2026-01-11 00:03:53,279 - INFO -   Race 2026-01-10_97_7: 7 starts (results)
2026-01-11 00:03:53,924 - INFO -   Race 2026-01-10_97_8: 9 starts (results)
2026-01-11 00:03:54,661 - INFO -   Race 2026-01-10_97_9: 10 starts (results)
2026-01-11 00:03:55,328 - INFO -   Race 2026-01-10_97_10: 6 starts (results)
2026-01-11 00:03:55,998 - INFO -   Race 2026-01-10_97_11: 11 starts (results)
2026-01-11 00:03:56,007 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:56,172 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:56,172 - INFO - Found V85 game: V85_2026-01-10_23_3 with 8 races
2026-01-11 00:03:56,172 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:03:56,172 - INFO - Fetching calendar for 2026-01-10
2026-01-11 00:03:56,325 - INFO - Found 4 tracks for 2026-01-10
2026-01-11 00:03:56,825 - INFO - Processing track: Romme
2026-01-11 00:03:57,490 - INFO -   Race 2026-01-10_23_1: 12 starts (results)
2026-01-11 00:03:58,151 - INFO -   Race 2026-01-10_23_2: 11 starts (results)
2026-01-11 00:03:58,845 - INFO -   Race 2026-01-10_23_3: 12 starts (results)
2026-01-11 00:03:59,505 - INFO -   Race 2026-01-10_23_4: 12 starts (results)
2026-01-11 00:04:00,162 - INFO -   Race 2026-01-10_23_5: 12 starts (results)
2026-01-11 00:04:00,823 - INFO -   Race 2026-01-10_23_6: 9 starts (results)
2026-01-11 00:04:01,484 - INFO -   Race 2026-01-10_23_7: 12 starts (results)
2026-01-11 00:04:02,149 - INFO -   Race 2026-01-10_23_8: 12 starts (results)
2026-01-11 00:04:02,793 - INFO -   Race 2026-01-10_23_9: 12 starts (results)
2026-01-11 00:04:03,452 - INFO -   Race 2026-01-10_23_10: 15 starts (results)
2026-01-11 00:04:03,452 - INFO - Processing track: Forus
2026-01-11 00:04:04,112 - INFO -   Race 2026-01-10_81_1: 8 starts (results)
2026-01-11 00:04:04,753 - INFO -   Race 2026-01-10_81_2: 10 starts (results)
2026-01-11 00:04:05,395 - INFO -   Race 2026-01-10_81_3: 6 starts (results)
2026-01-11 00:04:06,051 - INFO -   Race 2026-01-10_81_4: 15 starts (results)
2026-01-11 00:04:06,708 - INFO -   Race 2026-01-10_81_5: 11 starts (results)
2026-01-11 00:04:07,391 - INFO -   Race 2026-01-10_81_6: 14 starts (results)
2026-01-11 00:04:08,049 - INFO -   Race 2026-01-10_81_7: 9 starts (results)
2026-01-11 00:04:08,715 - INFO -   Race 2026-01-10_81_8: 10 starts (results)
2026-01-11 00:04:09,371 - INFO -   Race 2026-01-10_81_9: 12 starts (results)
2026-01-11 00:04:09,372 - INFO - Processing track: Vincennes
2026-01-11 00:04:10,029 - INFO -   Race 2026-01-10_63_1: 14 starts (results)
2026-01-11 00:04:10,683 - INFO -   Race 2026-01-10_63_2: 9 starts (results)
2026-01-11 00:04:11,329 - INFO -   Race 2026-01-10_63_3: 11 starts (results)
2026-01-11 00:04:11,985 - INFO -   Race 2026-01-10_63_4: 14 starts (results)
2026-01-11 00:04:12,689 - INFO -   Race 2026-01-10_63_5: 12 starts (results)
2026-01-11 00:04:13,407 - INFO -   Race 2026-01-10_63_6: 16 starts (results)
2026-01-11 00:04:14,059 - INFO -   Race 2026-01-10_63_7: 10 starts (results)
2026-01-11 00:04:14,719 - INFO -   Race 2026-01-10_63_8: 14 starts (results)
2026-01-11 00:04:15,392 - INFO -   Race 2026-01-10_63_9: 13 starts (results)
2026-01-11 00:04:15,392 - INFO - Processing track: Gulfstream Park
2026-01-11 00:04:16,051 - INFO -   Race 2026-01-10_97_1: 11 starts (results)
2026-01-11 00:04:16,704 - INFO -   Race 2026-01-10_97_2: 9 starts (results)
2026-01-11 00:04:17,349 - INFO -   Race 2026-01-10_97_3: 6 starts (results)
2026-01-11 00:04:17,999 - INFO -   Race 2026-01-10_97_4: 8 starts (results)
2026-01-11 00:04:18,670 - INFO -   Race 2026-01-10_97_5: 7 starts (results)
2026-01-11 00:04:19,325 - INFO -   Race 2026-01-10_97_6: 9 starts (results)
2026-01-11 00:04:19,987 - INFO -   Race 2026-01-10_97_7: 7 starts (results)
2026-01-11 00:04:20,641 - INFO -   Race 2026-01-10_97_8: 9 starts (results)
2026-01-11 00:04:21,298 - INFO -   Race 2026-01-10_97_9: 10 starts (results)
2026-01-11 00:04:21,956 - INFO -   Race 2026-01-10_97_10: 6 starts (results)
2026-01-11 00:04:22,598 - INFO -   Race 2026-01-10_97_11: 11 starts (results)
2026-01-11 00:04:22,606 - INFO - Fetching V85 races for 2026-01-03
2026-01-11 00:04:22,606 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:04:23,630 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:04:23,630 - INFO - Found V85 game: V85_2026-01-03_7_3 with 8 races
2026-01-11 00:04:23,630 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:04:23,630 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:04:23,787 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:04:24,287 - INFO - Processing track: Jägersro
2026-01-11 00:04:24,943 - INFO -   Race 2026-01-03_7_1: 15 starts (results)
2026-01-11 00:04:25,618 - INFO -   Race 2026-01-03_7_2: 12 starts (results)
2026-01-11 00:04:26,284 - INFO -   Race 2026-01-03_7_3: 15 starts (results)
2026-01-11 00:04:26,935 - INFO -   Race 2026-01-03_7_4: 8 starts (results)
2026-01-11 00:04:27,605 - INFO -   Race 2026-01-03_7_5: 12 starts (results)
2026-01-11 00:04:28,269 - INFO -   Race 2026-01-03_7_6: 9 starts (results)
2026-01-11 00:04:28,933 - INFO -   Race 2026-01-03_7_7: 12 starts (results)
2026-01-11 00:04:29,612 - INFO -   Race 2026-01-03_7_8: 12 starts (results)
2026-01-11 00:04:30,277 - INFO -   Race 2026-01-03_7_9: 12 starts (results)
2026-01-11 00:04:30,945 - INFO -   Race 2026-01-03_7_10: 12 starts (results)
2026-01-11 00:04:30,945 - INFO - Processing track: Ålborg
2026-01-11 00:04:31,629 - INFO -   Race 2026-01-03_54_1: 11 starts (results)
2026-01-11 00:04:32,344 - INFO -   Race 2026-01-03_54_2: 8 starts (results)
2026-01-11 00:04:33,026 - INFO -   Race 2026-01-03_54_3: 10 starts (results)
2026-01-11 00:04:33,680 - INFO -   Race 2026-01-03_54_4: 11 starts (results)
2026-01-11 00:04:34,363 - INFO -   Race 2026-01-03_54_5: 11 starts (results)
2026-01-11 00:04:35,048 - INFO -   Race 2026-01-03_54_6: 10 starts (results)
2026-01-11 00:04:35,713 - INFO -   Race 2026-01-03_54_7: 10 starts (results)
2026-01-11 00:04:36,393 - INFO -   Race 2026-01-03_54_8: 12 starts (results)
2026-01-11 00:04:37,089 - INFO -   Race 2026-01-03_54_9: 12 starts (results)
2026-01-11 00:04:37,089 - INFO - Processing track: Vincennes
2026-01-11 00:04:37,804 - INFO -   Race 2026-01-03_63_1: 10 starts (results)
2026-01-11 00:04:38,494 - INFO -   Race 2026-01-03_63_2: 14 starts (results)
2026-01-11 00:04:39,190 - INFO -   Race 2026-01-03_63_3: 12 starts (results)
2026-01-11 00:04:39,880 - INFO -   Race 2026-01-03_63_4: 16 starts (results)
2026-01-11 00:04:40,555 - INFO -   Race 2026-01-03_63_5: 16 starts (results)
2026-01-11 00:04:41,223 - INFO -   Race 2026-01-03_63_6: 16 starts (results)
2026-01-11 00:04:41,887 - INFO -   Race 2026-01-03_63_7: 10 starts (results)
2026-01-11 00:04:42,590 - INFO -   Race 2026-01-03_63_8: 16 starts (results)
2026-01-11 00:04:43,281 - INFO -   Race 2026-01-03_63_9: 12 starts (results)
2026-01-11 00:04:43,281 - INFO - Processing track: Gulfstream Park
2026-01-11 00:04:43,967 - INFO -   Race 2026-01-03_97_1: 10 starts (results)
2026-01-11 00:04:44,699 - INFO -   Race 2026-01-03_97_2: 9 starts (results)
2026-01-11 00:04:45,385 - INFO -   Race 2026-01-03_97_3: 8 starts (results)
2026-01-11 00:04:46,072 - INFO -   Race 2026-01-03_97_4: 7 starts (results)
2026-01-11 00:04:46,789 - INFO -   Race 2026-01-03_97_5: 8 starts (results)
2026-01-11 00:04:47,466 - INFO -   Race 2026-01-03_97_6: 8 starts (results)
2026-01-11 00:04:48,150 - INFO -   Race 2026-01-03_97_7: 8 starts (results)
2026-01-11 00:04:48,838 - INFO -   Race 2026-01-03_97_8: 11 starts (results)
2026-01-11 00:04:49,520 - INFO -   Race 2026-01-03_97_9: 7 starts (results)
2026-01-11 00:04:50,221 - INFO -   Race 2026-01-03_97_10: 9 starts (results)
2026-01-11 00:04:50,987 - INFO -   Race 2026-01-03_97_11: 11 starts (results)
2026-01-11 00:04:50,991 - INFO - V85 Game: V85_2026-01-03_7_3
2026-01-11 00:04:50,991 - INFO - Loaded 92 horses from 8 V85 races
2026-01-11 00:04:50,991 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:04:50,991 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:04:50,993 - INFO - Added temporal features
2026-01-11 00:04:50,994 - INFO - Added post position features
2026-01-11 00:04:50,994 - INFO - Calculated driver/trainer rates
2026-01-11 00:04:50,995 - INFO - Added speed features
2026-01-11 00:04:50,995 - INFO - Added track importance features
2026-01-11 00:04:50,997 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:04:51,176 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:04:51,794 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:04:51,794 - INFO - Found V85 game: V85_2026-01-03_7_3 with 8 races
2026-01-11 00:04:51,794 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:04:51,794 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:04:51,947 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:04:52,447 - INFO - Processing track: Jägersro
2026-01-11 00:04:53,099 - INFO -   Race 2026-01-03_7_1: 15 starts (results)
2026-01-11 00:04:53,757 - INFO -   Race 2026-01-03_7_2: 12 starts (results)
2026-01-11 00:04:54,412 - INFO -   Race 2026-01-03_7_3: 15 starts (results)
2026-01-11 00:04:55,099 - INFO -   Race 2026-01-03_7_4: 8 starts (results)
2026-01-11 00:04:55,749 - INFO -   Race 2026-01-03_7_5: 12 starts (results)
2026-01-11 00:04:56,417 - INFO -   Race 2026-01-03_7_6: 9 starts (results)
2026-01-11 00:04:57,090 - INFO -   Race 2026-01-03_7_7: 12 starts (results)
2026-01-11 00:04:57,842 - INFO -   Race 2026-01-03_7_8: 12 starts (results)
2026-01-11 00:04:58,565 - INFO -   Race 2026-01-03_7_9: 12 starts (results)
2026-01-11 00:04:59,236 - INFO -   Race 2026-01-03_7_10: 12 starts (results)
2026-01-11 00:04:59,236 - INFO - Processing track: Ålborg
2026-01-11 00:04:59,903 - INFO -   Race 2026-01-03_54_1: 11 starts (results)
2026-01-11 00:05:00,587 - INFO -   Race 2026-01-03_54_2: 8 starts (results)
2026-01-11 00:05:01,235 - INFO -   Race 2026-01-03_54_3: 10 starts (results)
2026-01-11 00:05:01,897 - INFO -   Race 2026-01-03_54_4: 11 starts (results)
2026-01-11 00:05:02,554 - INFO -   Race 2026-01-03_54_5: 11 starts (results)
2026-01-11 00:05:03,216 - INFO -   Race 2026-01-03_54_6: 10 starts (results)
2026-01-11 00:05:03,890 - INFO -   Race 2026-01-03_54_7: 10 starts (results)
2026-01-11 00:05:04,560 - INFO -   Race 2026-01-03_54_8: 12 starts (results)
2026-01-11 00:05:05,224 - INFO -   Race 2026-01-03_54_9: 12 starts (results)
2026-01-11 00:05:05,224 - INFO - Processing track: Vincennes
2026-01-11 00:05:05,878 - INFO -   Race 2026-01-03_63_1: 10 starts (results)
2026-01-11 00:05:06,561 - INFO -   Race 2026-01-03_63_2: 14 starts (results)
2026-01-11 00:05:07,217 - INFO -   Race 2026-01-03_63_3: 12 starts (results)
2026-01-11 00:05:07,880 - INFO -   Race 2026-01-03_63_4: 16 starts (results)
2026-01-11 00:05:08,546 - INFO -   Race 2026-01-03_63_5: 16 starts (results)
2026-01-11 00:05:09,207 - INFO -   Race 2026-01-03_63_6: 16 starts (results)
2026-01-11 00:05:09,866 - INFO -   Race 2026-01-03_63_7: 10 starts (results)
2026-01-11 00:05:10,528 - INFO -   Race 2026-01-03_63_8: 16 starts (results)
2026-01-11 00:05:11,189 - INFO -   Race 2026-01-03_63_9: 12 starts (results)
2026-01-11 00:05:11,190 - INFO - Processing track: Gulfstream Park
2026-01-11 00:05:11,861 - INFO -   Race 2026-01-03_97_1: 10 starts (results)
2026-01-11 00:05:12,516 - INFO -   Race 2026-01-03_97_2: 9 starts (results)
2026-01-11 00:05:13,165 - INFO -   Race 2026-01-03_97_3: 8 starts (results)
2026-01-11 00:05:13,831 - INFO -   Race 2026-01-03_97_4: 7 starts (results)
2026-01-11 00:05:14,479 - INFO -   Race 2026-01-03_97_5: 8 starts (results)
2026-01-11 00:05:15,143 - INFO -   Race 2026-01-03_97_6: 8 starts (results)
2026-01-11 00:05:15,813 - INFO -   Race 2026-01-03_97_7: 8 starts (results)
2026-01-11 00:05:16,474 - INFO -   Race 2026-01-03_97_8: 11 starts (results)
2026-01-11 00:05:17,131 - INFO -   Race 2026-01-03_97_9: 7 starts (results)
2026-01-11 00:05:17,777 - INFO -   Race 2026-01-03_97_10: 9 starts (results)
2026-01-11 00:05:18,427 - INFO -   Race 2026-01-03_97_11: 11 starts (results)
2026-01-11 00:05:18,436 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:05:18,589 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:05:18,589 - INFO - Found V85 game: V85_2026-01-03_7_3 with 8 races
2026-01-11 00:05:18,589 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:05:18,589 - INFO - Fetching calendar for 2026-01-03
2026-01-11 00:05:18,739 - INFO - Found 4 tracks for 2026-01-03
2026-01-11 00:05:19,239 - INFO - Processing track: Jägersro
2026-01-11 00:05:19,895 - INFO -   Race 2026-01-03_7_1: 15 starts (results)
2026-01-11 00:05:21,093 - INFO -   Race 2026-01-03_7_2: 12 starts (results)
2026-01-11 00:05:21,754 - INFO -   Race 2026-01-03_7_3: 15 starts (results)
2026-01-11 00:05:22,413 - INFO -   Race 2026-01-03_7_4: 8 starts (results)
2026-01-11 00:05:23,078 - INFO -   Race 2026-01-03_7_5: 12 starts (results)
2026-01-11 00:05:23,735 - INFO -   Race 2026-01-03_7_6: 9 starts (results)
2026-01-11 00:05:24,388 - INFO -   Race 2026-01-03_7_7: 12 starts (results)
2026-01-11 00:05:25,060 - INFO -   Race 2026-01-03_7_8: 12 starts (results)
2026-01-11 00:05:25,767 - INFO -   Race 2026-01-03_7_9: 12 starts (results)
2026-01-11 00:05:26,427 - INFO -   Race 2026-01-03_7_10: 12 starts (results)
2026-01-11 00:05:26,427 - INFO - Processing track: Ålborg
2026-01-11 00:05:27,084 - INFO -   Race 2026-01-03_54_1: 11 starts (results)
2026-01-11 00:05:27,765 - INFO -   Race 2026-01-03_54_2: 8 starts (results)
2026-01-11 00:05:28,422 - INFO -   Race 2026-01-03_54_3: 10 starts (results)
2026-01-11 00:05:29,183 - INFO -   Race 2026-01-03_54_4: 11 starts (results)
2026-01-11 00:05:29,896 - INFO -   Race 2026-01-03_54_5: 11 starts (results)
2026-01-11 00:05:30,552 - INFO -   Race 2026-01-03_54_6: 10 starts (results)
2026-01-11 00:05:31,203 - INFO -   Race 2026-01-03_54_7: 10 starts (results)
2026-01-11 00:05:31,860 - INFO -   Race 2026-01-03_54_8: 12 starts (results)
2026-01-11 00:05:32,528 - INFO -   Race 2026-01-03_54_9: 12 starts (results)
2026-01-11 00:05:32,528 - INFO - Processing track: Vincennes
2026-01-11 00:05:33,170 - INFO -   Race 2026-01-03_63_1: 10 starts (results)
2026-01-11 00:05:33,809 - INFO -   Race 2026-01-03_63_2: 14 starts (results)
2026-01-11 00:05:34,455 - INFO -   Race 2026-01-03_63_3: 12 starts (results)
2026-01-11 00:05:35,102 - INFO -   Race 2026-01-03_63_4: 16 starts (results)
2026-01-11 00:05:35,772 - INFO -   Race 2026-01-03_63_5: 16 starts (results)
2026-01-11 00:05:36,430 - INFO -   Race 2026-01-03_63_6: 16 starts (results)
2026-01-11 00:05:37,090 - INFO -   Race 2026-01-03_63_7: 10 starts (results)
2026-01-11 00:05:37,740 - INFO -   Race 2026-01-03_63_8: 16 starts (results)
2026-01-11 00:05:38,391 - INFO -   Race 2026-01-03_63_9: 12 starts (results)
2026-01-11 00:05:38,391 - INFO - Processing track: Gulfstream Park
2026-01-11 00:05:39,051 - INFO -   Race 2026-01-03_97_1: 10 starts (results)
2026-01-11 00:05:39,714 - INFO -   Race 2026-01-03_97_2: 9 starts (results)
2026-01-11 00:05:40,357 - INFO -   Race 2026-01-03_97_3: 8 starts (results)
2026-01-11 00:05:41,014 - INFO -   Race 2026-01-03_97_4: 7 starts (results)
2026-01-11 00:05:41,673 - INFO -   Race 2026-01-03_97_5: 8 starts (results)
2026-01-11 00:05:42,323 - INFO -   Race 2026-01-03_97_6: 8 starts (results)
2026-01-11 00:05:43,003 - INFO -   Race 2026-01-03_97_7: 8 starts (results)
2026-01-11 00:05:43,662 - INFO -   Race 2026-01-03_97_8: 11 starts (results)
2026-01-11 00:05:44,321 - INFO -   Race 2026-01-03_97_9: 7 starts (results)
2026-01-11 00:05:44,971 - INFO -   Race 2026-01-03_97_10: 9 starts (results)
2026-01-11 00:05:45,671 - INFO -   Race 2026-01-03_97_11: 11 starts (results)
2026-01-11 00:05:45,678 - INFO - Fetching V85 races for 2025-12-31
2026-01-11 00:05:45,678 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:05:46,667 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:05:46,667 - INFO - Found V85 game: V85_2025-12-31_8_3 with 8 races
2026-01-11 00:05:46,667 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:05:46,667 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:05:46,816 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:05:47,316 - INFO - Processing track: Axevalla
2026-01-11 00:05:48,014 - INFO -   Race 2025-12-31_8_1: 15 starts (results)
2026-01-11 00:05:48,725 - INFO -   Race 2025-12-31_8_2: 12 starts (results)
2026-01-11 00:05:49,383 - INFO -   Race 2025-12-31_8_3: 15 starts (results)
2026-01-11 00:05:50,064 - INFO -   Race 2025-12-31_8_4: 12 starts (results)
2026-01-11 00:05:50,753 - INFO -   Race 2025-12-31_8_5: 12 starts (results)
2026-01-11 00:05:51,413 - INFO -   Race 2025-12-31_8_6: 15 starts (results)
2026-01-11 00:05:52,081 - INFO -   Race 2025-12-31_8_7: 12 starts (results)
2026-01-11 00:05:52,746 - INFO -   Race 2025-12-31_8_8: 12 starts (results)
2026-01-11 00:05:53,407 - INFO -   Race 2025-12-31_8_9: 15 starts (results)
2026-01-11 00:05:54,078 - INFO -   Race 2025-12-31_8_10: 15 starts (results)
2026-01-11 00:05:54,078 - INFO - Processing track: Århus
2026-01-11 00:05:54,760 - INFO -   Race 2025-12-31_54_1: 12 starts (results)
2026-01-11 00:05:55,424 - INFO -   Race 2025-12-31_54_2: 8 starts (results)
2026-01-11 00:05:56,093 - INFO -   Race 2025-12-31_54_3: 12 starts (results)
2026-01-11 00:05:56,759 - INFO -   Race 2025-12-31_54_4: 12 starts (results)
2026-01-11 00:05:57,425 - INFO -   Race 2025-12-31_54_5: 12 starts (results)
2026-01-11 00:05:58,086 - INFO -   Race 2025-12-31_54_6: 12 starts (results)
2026-01-11 00:05:58,759 - INFO -   Race 2025-12-31_54_7: 8 starts (results)
2026-01-11 00:05:59,473 - INFO -   Race 2025-12-31_54_8: 13 starts (results)
2026-01-11 00:05:59,473 - INFO - Processing track: Vincennes
2026-01-11 00:06:00,165 - INFO -   Race 2025-12-31_63_1: 11 starts (results)
2026-01-11 00:06:00,854 - INFO -   Race 2025-12-31_63_2: 11 starts (results)
2026-01-11 00:06:01,547 - INFO -   Race 2025-12-31_63_3: 13 starts (results)
2026-01-11 00:06:02,225 - INFO -   Race 2025-12-31_63_4: 13 starts (results)
2026-01-11 00:06:02,921 - INFO -   Race 2025-12-31_63_5: 16 starts (results)
2026-01-11 00:06:03,685 - INFO -   Race 2025-12-31_63_6: 15 starts (results)
2026-01-11 00:06:04,370 - INFO -   Race 2025-12-31_63_7: 10 starts (results)
2026-01-11 00:06:05,058 - INFO -   Race 2025-12-31_63_8: 12 starts (results)
2026-01-11 00:06:05,749 - INFO -   Race 2025-12-31_63_9: 14 starts (results)
2026-01-11 00:06:06,553 - INFO -   Race 2025-12-31_63_10: 16 starts (results)
2026-01-11 00:06:06,553 - INFO - Processing track: Lingfield
2026-01-11 00:06:07,231 - INFO -   Race 2025-12-31_71_1: 10 starts (results)
2026-01-11 00:06:07,939 - INFO -   Race 2025-12-31_71_2: 7 starts (results)
2026-01-11 00:06:08,631 - INFO -   Race 2025-12-31_71_3: 7 starts (results)
2026-01-11 00:06:09,324 - INFO -   Race 2025-12-31_71_4: 5 starts (results)
2026-01-11 00:06:10,004 - INFO -   Race 2025-12-31_71_5: 5 starts (results)
2026-01-11 00:06:11,264 - INFO -   Race 2025-12-31_71_6: 6 starts (results)
2026-01-11 00:06:11,940 - INFO -   Race 2025-12-31_71_7: 6 starts (results)
2026-01-11 00:06:12,630 - INFO -   Race 2025-12-31_71_8: 11 starts (results)
2026-01-11 00:06:12,634 - INFO - V85 Game: V85_2025-12-31_8_3
2026-01-11 00:06:12,634 - INFO - Loaded 108 horses from 8 V85 races
2026-01-11 00:06:12,634 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:06:12,634 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:06:12,636 - INFO - Added temporal features
2026-01-11 00:06:12,637 - INFO - Added post position features
2026-01-11 00:06:12,637 - INFO - Calculated driver/trainer rates
2026-01-11 00:06:12,638 - INFO - Added speed features
2026-01-11 00:06:12,638 - INFO - Added track importance features
2026-01-11 00:06:12,640 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:06:12,798 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:06:13,414 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:06:13,414 - INFO - Found V85 game: V85_2025-12-31_8_3 with 8 races
2026-01-11 00:06:13,415 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:06:13,415 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:06:13,560 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:06:14,060 - INFO - Processing track: Axevalla
2026-01-11 00:06:14,751 - INFO -   Race 2025-12-31_8_1: 15 starts (results)
2026-01-11 00:06:15,417 - INFO -   Race 2025-12-31_8_2: 12 starts (results)
2026-01-11 00:06:16,112 - INFO -   Race 2025-12-31_8_3: 15 starts (results)
2026-01-11 00:06:16,773 - INFO -   Race 2025-12-31_8_4: 12 starts (results)
2026-01-11 00:06:17,438 - INFO -   Race 2025-12-31_8_5: 12 starts (results)
2026-01-11 00:06:18,095 - INFO -   Race 2025-12-31_8_6: 15 starts (results)
2026-01-11 00:06:18,761 - INFO -   Race 2025-12-31_8_7: 12 starts (results)
2026-01-11 00:06:19,428 - INFO -   Race 2025-12-31_8_8: 12 starts (results)
2026-01-11 00:06:20,099 - INFO -   Race 2025-12-31_8_9: 15 starts (results)
2026-01-11 00:06:20,765 - INFO -   Race 2025-12-31_8_10: 15 starts (results)
2026-01-11 00:06:20,765 - INFO - Processing track: Århus
2026-01-11 00:06:21,429 - INFO -   Race 2025-12-31_54_1: 12 starts (results)
2026-01-11 00:06:22,085 - INFO -   Race 2025-12-31_54_2: 8 starts (results)
2026-01-11 00:06:22,746 - INFO -   Race 2025-12-31_54_3: 12 starts (results)
2026-01-11 00:06:23,394 - INFO -   Race 2025-12-31_54_4: 12 starts (results)
2026-01-11 00:06:24,058 - INFO -   Race 2025-12-31_54_5: 12 starts (results)
2026-01-11 00:06:24,722 - INFO -   Race 2025-12-31_54_6: 12 starts (results)
2026-01-11 00:06:25,381 - INFO -   Race 2025-12-31_54_7: 8 starts (results)
2026-01-11 00:06:26,055 - INFO -   Race 2025-12-31_54_8: 13 starts (results)
2026-01-11 00:06:26,055 - INFO - Processing track: Vincennes
2026-01-11 00:06:26,713 - INFO -   Race 2025-12-31_63_1: 11 starts (results)
2026-01-11 00:06:27,382 - INFO -   Race 2025-12-31_63_2: 11 starts (results)
2026-01-11 00:06:28,059 - INFO -   Race 2025-12-31_63_3: 13 starts (results)
2026-01-11 00:06:28,716 - INFO -   Race 2025-12-31_63_4: 13 starts (results)
2026-01-11 00:06:29,595 - INFO -   Race 2025-12-31_63_5: 16 starts (results)
2026-01-11 00:06:30,258 - INFO -   Race 2025-12-31_63_6: 15 starts (results)
2026-01-11 00:06:31,032 - INFO -   Race 2025-12-31_63_7: 10 starts (results)
2026-01-11 00:06:31,697 - INFO -   Race 2025-12-31_63_8: 12 starts (results)
2026-01-11 00:06:32,355 - INFO -   Race 2025-12-31_63_9: 14 starts (results)
2026-01-11 00:06:33,015 - INFO -   Race 2025-12-31_63_10: 16 starts (results)
2026-01-11 00:06:33,015 - INFO - Processing track: Lingfield
2026-01-11 00:06:33,679 - INFO -   Race 2025-12-31_71_1: 10 starts (results)
2026-01-11 00:06:34,350 - INFO -   Race 2025-12-31_71_2: 7 starts (results)
2026-01-11 00:06:35,008 - INFO -   Race 2025-12-31_71_3: 7 starts (results)
2026-01-11 00:06:35,672 - INFO -   Race 2025-12-31_71_4: 5 starts (results)
2026-01-11 00:06:36,365 - INFO -   Race 2025-12-31_71_5: 5 starts (results)
2026-01-11 00:06:37,012 - INFO -   Race 2025-12-31_71_6: 6 starts (results)
2026-01-11 00:06:37,683 - INFO -   Race 2025-12-31_71_7: 6 starts (results)
2026-01-11 00:06:38,330 - INFO -   Race 2025-12-31_71_8: 11 starts (results)
2026-01-11 00:06:38,339 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:06:38,500 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:06:38,500 - INFO - Found V85 game: V85_2025-12-31_8_3 with 8 races
2026-01-11 00:06:38,500 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:06:38,500 - INFO - Fetching calendar for 2025-12-31
2026-01-11 00:06:38,647 - INFO - Found 4 tracks for 2025-12-31
2026-01-11 00:06:39,147 - INFO - Processing track: Axevalla
2026-01-11 00:06:39,806 - INFO -   Race 2025-12-31_8_1: 15 starts (results)
2026-01-11 00:06:40,461 - INFO -   Race 2025-12-31_8_2: 12 starts (results)
2026-01-11 00:06:41,132 - INFO -   Race 2025-12-31_8_3: 15 starts (results)
2026-01-11 00:06:41,792 - INFO -   Race 2025-12-31_8_4: 12 starts (results)
2026-01-11 00:06:42,451 - INFO -   Race 2025-12-31_8_5: 12 starts (results)
2026-01-11 00:06:43,113 - INFO -   Race 2025-12-31_8_6: 15 starts (results)
2026-01-11 00:06:43,762 - INFO -   Race 2025-12-31_8_7: 12 starts (results)
2026-01-11 00:06:44,435 - INFO -   Race 2025-12-31_8_8: 12 starts (results)
2026-01-11 00:06:45,080 - INFO -   Race 2025-12-31_8_9: 15 starts (results)
2026-01-11 00:06:45,734 - INFO -   Race 2025-12-31_8_10: 15 starts (results)
2026-01-11 00:06:45,734 - INFO - Processing track: Århus
2026-01-11 00:06:46,378 - INFO -   Race 2025-12-31_54_1: 12 starts (results)
2026-01-11 00:06:47,051 - INFO -   Race 2025-12-31_54_2: 8 starts (results)
2026-01-11 00:06:47,710 - INFO -   Race 2025-12-31_54_3: 12 starts (results)
2026-01-11 00:06:48,360 - INFO -   Race 2025-12-31_54_4: 12 starts (results)
2026-01-11 00:06:49,022 - INFO -   Race 2025-12-31_54_5: 12 starts (results)
2026-01-11 00:06:49,672 - INFO -   Race 2025-12-31_54_6: 12 starts (results)
2026-01-11 00:06:50,318 - INFO -   Race 2025-12-31_54_7: 8 starts (results)
2026-01-11 00:06:50,987 - INFO -   Race 2025-12-31_54_8: 13 starts (results)
2026-01-11 00:06:50,987 - INFO - Processing track: Vincennes
2026-01-11 00:06:51,660 - INFO -   Race 2025-12-31_63_1: 11 starts (results)
2026-01-11 00:06:52,309 - INFO -   Race 2025-12-31_63_2: 11 starts (results)
2026-01-11 00:06:52,979 - INFO -   Race 2025-12-31_63_3: 13 starts (results)
2026-01-11 00:06:53,637 - INFO -   Race 2025-12-31_63_4: 13 starts (results)
2026-01-11 00:06:54,304 - INFO -   Race 2025-12-31_63_5: 16 starts (results)
2026-01-11 00:06:55,003 - INFO -   Race 2025-12-31_63_6: 15 starts (results)
2026-01-11 00:06:55,671 - INFO -   Race 2025-12-31_63_7: 10 starts (results)
2026-01-11 00:06:56,338 - INFO -   Race 2025-12-31_63_8: 12 starts (results)
2026-01-11 00:06:56,993 - INFO -   Race 2025-12-31_63_9: 14 starts (results)
2026-01-11 00:06:57,640 - INFO -   Race 2025-12-31_63_10: 16 starts (results)
2026-01-11 00:06:57,640 - INFO - Processing track: Lingfield
2026-01-11 00:06:58,313 - INFO -   Race 2025-12-31_71_1: 10 starts (results)
2026-01-11 00:06:58,972 - INFO -   Race 2025-12-31_71_2: 7 starts (results)
2026-01-11 00:06:59,637 - INFO -   Race 2025-12-31_71_3: 7 starts (results)
2026-01-11 00:07:00,284 - INFO -   Race 2025-12-31_71_4: 5 starts (results)
2026-01-11 00:07:00,939 - INFO -   Race 2025-12-31_71_5: 5 starts (results)
2026-01-11 00:07:01,595 - INFO -   Race 2025-12-31_71_6: 6 starts (results)
2026-01-11 00:07:02,256 - INFO -   Race 2025-12-31_71_7: 6 starts (results)
2026-01-11 00:07:02,914 - INFO -   Race 2025-12-31_71_8: 11 starts (results)
2026-01-11 00:07:02,921 - INFO - Fetching V85 races for 2025-12-30
2026-01-11 00:07:02,921 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:07:04,046 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:07:04,046 - INFO - Found V85 game: V85_2025-12-30_78_3 with 8 races
2026-01-11 00:07:04,046 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:07:04,046 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:07:04,184 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:07:04,684 - INFO - Processing track: Bjerke
2026-01-11 00:07:05,439 - INFO -   Race 2025-12-30_78_1: 7 starts (results)
2026-01-11 00:07:06,135 - INFO -   Race 2025-12-30_78_2: 10 starts (results)
2026-01-11 00:07:06,798 - INFO -   Race 2025-12-30_78_3: 11 starts (results)
2026-01-11 00:07:07,464 - INFO -   Race 2025-12-30_78_4: 11 starts (results)
2026-01-11 00:07:08,124 - INFO -   Race 2025-12-30_78_5: 12 starts (results)
2026-01-11 00:07:08,812 - INFO -   Race 2025-12-30_78_6: 9 starts (results)
2026-01-11 00:07:09,472 - INFO -   Race 2025-12-30_78_7: 12 starts (results)
2026-01-11 00:07:10,156 - INFO -   Race 2025-12-30_78_8: 12 starts (results)
2026-01-11 00:07:10,830 - INFO -   Race 2025-12-30_78_9: 9 starts (results)
2026-01-11 00:07:11,491 - INFO -   Race 2025-12-30_78_10: 12 starts (results)
2026-01-11 00:07:11,491 - INFO - Processing track: Charlottenlund
2026-01-11 00:07:12,160 - INFO -   Race 2025-12-30_55_1: 10 starts (results)
2026-01-11 00:07:12,811 - INFO -   Race 2025-12-30_55_2: 11 starts (results)
2026-01-11 00:07:13,465 - INFO -   Race 2025-12-30_55_3: 13 starts (results)
2026-01-11 00:07:14,166 - INFO -   Race 2025-12-30_55_4: 11 starts (results)
2026-01-11 00:07:14,834 - INFO -   Race 2025-12-30_55_5: 10 starts (results)
2026-01-11 00:07:15,498 - INFO -   Race 2025-12-30_55_6: 9 starts (results)
2026-01-11 00:07:16,197 - INFO -   Race 2025-12-30_55_7: 9 starts (results)
2026-01-11 00:07:16,882 - INFO -   Race 2025-12-30_55_8: 10 starts (results)
2026-01-11 00:07:17,600 - INFO -   Race 2025-12-30_55_9: 10 starts (results)
2026-01-11 00:07:17,600 - INFO - Processing track: Boden
2026-01-11 00:07:18,440 - INFO -   Race 2025-12-30_11_1: 12 starts (results)
2026-01-11 00:07:19,206 - INFO -   Race 2025-12-30_11_2: 13 starts (results)
2026-01-11 00:07:19,912 - INFO -   Race 2025-12-30_11_3: 12 starts (results)
2026-01-11 00:07:20,619 - INFO -   Race 2025-12-30_11_4: 12 starts (results)
2026-01-11 00:07:21,315 - INFO -   Race 2025-12-30_11_5: 8 starts (results)
2026-01-11 00:07:22,015 - INFO -   Race 2025-12-30_11_6: 13 starts (results)
2026-01-11 00:07:22,729 - INFO -   Race 2025-12-30_11_7: 15 starts (results)
2026-01-11 00:07:23,421 - INFO -   Race 2025-12-30_11_8: 11 starts (results)
2026-01-11 00:07:24,179 - INFO -   Race 2025-12-30_11_9: 15 starts (results)
2026-01-11 00:07:24,179 - INFO - Processing track: Mantorp
2026-01-11 00:07:24,874 - INFO -   Race 2025-12-30_22_1: 12 starts (results)
2026-01-11 00:07:25,591 - INFO -   Race 2025-12-30_22_2: 12 starts (results)
2026-01-11 00:07:26,292 - INFO -   Race 2025-12-30_22_3: 15 starts (results)
2026-01-11 00:07:26,971 - INFO -   Race 2025-12-30_22_4: 12 starts (results)
2026-01-11 00:07:27,692 - INFO -   Race 2025-12-30_22_5: 12 starts (results)
2026-01-11 00:07:28,473 - INFO -   Race 2025-12-30_22_6: 12 starts (results)
2026-01-11 00:07:29,190 - INFO -   Race 2025-12-30_22_7: 12 starts (results)
2026-01-11 00:07:29,910 - INFO -   Race 2025-12-30_22_8: 12 starts (results)
2026-01-11 00:07:29,910 - INFO - Processing track: Vincennes
2026-01-11 00:07:30,630 - INFO -   Race 2025-12-30_63_1: 11 starts (results)
2026-01-11 00:07:31,309 - INFO -   Race 2025-12-30_63_2: 11 starts (results)
2026-01-11 00:07:32,006 - INFO -   Race 2025-12-30_63_3: 13 starts (results)
2026-01-11 00:07:32,694 - INFO -   Race 2025-12-30_63_4: 12 starts (results)
2026-01-11 00:07:33,496 - INFO -   Race 2025-12-30_63_5: 11 starts (results)
2026-01-11 00:07:34,190 - INFO -   Race 2025-12-30_63_6: 16 starts (results)
2026-01-11 00:07:35,029 - INFO -   Race 2025-12-30_63_7: 10 starts (results)
2026-01-11 00:07:35,727 - INFO -   Race 2025-12-30_63_8: 14 starts (results)
2026-01-11 00:07:35,727 - INFO - Processing track: Turffontein
2026-01-11 00:07:36,439 - INFO -   Race 2025-12-30_89_1: 9 starts (results)
2026-01-11 00:07:37,115 - INFO -   Race 2025-12-30_89_2: 8 starts (results)
2026-01-11 00:07:37,818 - INFO -   Race 2025-12-30_89_3: 9 starts (results)
2026-01-11 00:07:38,613 - INFO -   Race 2025-12-30_89_4: 9 starts (results)
2026-01-11 00:07:39,297 - INFO -   Race 2025-12-30_89_5: 10 starts (results)
2026-01-11 00:07:39,992 - INFO -   Race 2025-12-30_89_6: 6 starts (results)
2026-01-11 00:07:40,685 - INFO -   Race 2025-12-30_89_7: 6 starts (results)
2026-01-11 00:07:41,362 - INFO -   Race 2025-12-30_89_8: 9 starts (results)
2026-01-11 00:07:42,063 - INFO -   Race 2025-12-30_89_9: 8 starts (results)
2026-01-11 00:07:42,810 - INFO -   Race 2025-12-30_89_10: 11 starts (results)
2026-01-11 00:07:42,814 - INFO - V85 Game: V85_2025-12-30_78_3
2026-01-11 00:07:42,814 - INFO - Loaded 88 horses from 8 V85 races
2026-01-11 00:07:42,814 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:07:42,814 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:07:42,816 - INFO - Added temporal features
2026-01-11 00:07:42,817 - INFO - Added post position features
2026-01-11 00:07:42,818 - INFO - Calculated driver/trainer rates
2026-01-11 00:07:42,818 - INFO - Added speed features
2026-01-11 00:07:42,819 - INFO - Added track importance features
/home/per/Work/trav/api_data_processor.py:142: FutureWarning: The behavior of Index.insert with object-dtype is deprecated, in a future version this will return an object-dtype Index instead of inferring a non-object dtype. To retain the old behavior, do `idx.insert(loc, item).infer_objects(copy=False)`
  condition_dummies = pd.get_dummies(df['track_condition'], prefix='condition', dummy_na=True)
2026-01-11 00:07:42,820 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:07:42,976 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:07:44,039 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:07:44,039 - INFO - Found V85 game: V85_2025-12-30_78_3 with 8 races
2026-01-11 00:07:44,039 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:07:44,039 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:07:44,188 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:07:44,688 - INFO - Processing track: Bjerke
2026-01-11 00:07:45,378 - INFO -   Race 2025-12-30_78_1: 7 starts (results)
2026-01-11 00:07:46,068 - INFO -   Race 2025-12-30_78_2: 10 starts (results)
2026-01-11 00:07:46,720 - INFO -   Race 2025-12-30_78_3: 11 starts (results)
2026-01-11 00:07:47,391 - INFO -   Race 2025-12-30_78_4: 11 starts (results)
2026-01-11 00:07:48,059 - INFO -   Race 2025-12-30_78_5: 12 starts (results)
2026-01-11 00:07:48,755 - INFO -   Race 2025-12-30_78_6: 9 starts (results)
2026-01-11 00:07:49,471 - INFO -   Race 2025-12-30_78_7: 12 starts (results)
2026-01-11 00:07:50,142 - INFO -   Race 2025-12-30_78_8: 12 starts (results)
2026-01-11 00:07:50,812 - INFO -   Race 2025-12-30_78_9: 9 starts (results)
2026-01-11 00:07:51,474 - INFO -   Race 2025-12-30_78_10: 12 starts (results)
2026-01-11 00:07:51,474 - INFO - Processing track: Charlottenlund
2026-01-11 00:07:52,128 - INFO -   Race 2025-12-30_55_1: 10 starts (results)
2026-01-11 00:07:52,791 - INFO -   Race 2025-12-30_55_2: 11 starts (results)
2026-01-11 00:07:53,438 - INFO -   Race 2025-12-30_55_3: 13 starts (results)
2026-01-11 00:07:54,101 - INFO -   Race 2025-12-30_55_4: 11 starts (results)
2026-01-11 00:07:54,764 - INFO -   Race 2025-12-30_55_5: 10 starts (results)
2026-01-11 00:07:55,426 - INFO -   Race 2025-12-30_55_6: 9 starts (results)
2026-01-11 00:07:56,097 - INFO -   Race 2025-12-30_55_7: 9 starts (results)
2026-01-11 00:07:56,758 - INFO -   Race 2025-12-30_55_8: 10 starts (results)
2026-01-11 00:07:57,452 - INFO -   Race 2025-12-30_55_9: 10 starts (results)
2026-01-11 00:07:57,452 - INFO - Processing track: Boden
2026-01-11 00:07:58,118 - INFO -   Race 2025-12-30_11_1: 12 starts (results)
2026-01-11 00:07:58,790 - INFO -   Race 2025-12-30_11_2: 13 starts (results)
2026-01-11 00:07:59,457 - INFO -   Race 2025-12-30_11_3: 12 starts (results)
2026-01-11 00:08:00,121 - INFO -   Race 2025-12-30_11_4: 12 starts (results)
2026-01-11 00:08:00,786 - INFO -   Race 2025-12-30_11_5: 8 starts (results)
2026-01-11 00:08:01,468 - INFO -   Race 2025-12-30_11_6: 13 starts (results)
2026-01-11 00:08:02,145 - INFO -   Race 2025-12-30_11_7: 15 starts (results)
2026-01-11 00:08:02,886 - INFO -   Race 2025-12-30_11_8: 11 starts (results)
2026-01-11 00:08:03,541 - INFO -   Race 2025-12-30_11_9: 15 starts (results)
2026-01-11 00:08:03,541 - INFO - Processing track: Mantorp
2026-01-11 00:08:04,220 - INFO -   Race 2025-12-30_22_1: 12 starts (results)
2026-01-11 00:08:04,891 - INFO -   Race 2025-12-30_22_2: 12 starts (results)
2026-01-11 00:08:05,555 - INFO -   Race 2025-12-30_22_3: 15 starts (results)
2026-01-11 00:08:06,239 - INFO -   Race 2025-12-30_22_4: 12 starts (results)
2026-01-11 00:08:06,914 - INFO -   Race 2025-12-30_22_5: 12 starts (results)
2026-01-11 00:08:07,587 - INFO -   Race 2025-12-30_22_6: 12 starts (results)
2026-01-11 00:08:08,237 - INFO -   Race 2025-12-30_22_7: 12 starts (results)
2026-01-11 00:08:08,911 - INFO -   Race 2025-12-30_22_8: 12 starts (results)
2026-01-11 00:08:08,911 - INFO - Processing track: Vincennes
2026-01-11 00:08:09,564 - INFO -   Race 2025-12-30_63_1: 11 starts (results)
2026-01-11 00:08:10,230 - INFO -   Race 2025-12-30_63_2: 11 starts (results)
2026-01-11 00:08:10,913 - INFO -   Race 2025-12-30_63_3: 13 starts (results)
2026-01-11 00:08:11,686 - INFO -   Race 2025-12-30_63_4: 12 starts (results)
2026-01-11 00:08:12,347 - INFO -   Race 2025-12-30_63_5: 11 starts (results)
2026-01-11 00:08:13,029 - INFO -   Race 2025-12-30_63_6: 16 starts (results)
2026-01-11 00:08:13,703 - INFO -   Race 2025-12-30_63_7: 10 starts (results)
2026-01-11 00:08:14,450 - INFO -   Race 2025-12-30_63_8: 14 starts (results)
2026-01-11 00:08:14,451 - INFO - Processing track: Turffontein
2026-01-11 00:08:15,104 - INFO -   Race 2025-12-30_89_1: 9 starts (results)
2026-01-11 00:08:15,769 - INFO -   Race 2025-12-30_89_2: 8 starts (results)
2026-01-11 00:08:16,429 - INFO -   Race 2025-12-30_89_3: 9 starts (results)
2026-01-11 00:08:17,075 - INFO -   Race 2025-12-30_89_4: 9 starts (results)
2026-01-11 00:08:17,729 - INFO -   Race 2025-12-30_89_5: 10 starts (results)
2026-01-11 00:08:18,389 - INFO -   Race 2025-12-30_89_6: 6 starts (results)
2026-01-11 00:08:19,060 - INFO -   Race 2025-12-30_89_7: 6 starts (results)
2026-01-11 00:08:19,709 - INFO -   Race 2025-12-30_89_8: 9 starts (results)
2026-01-11 00:08:20,373 - INFO -   Race 2025-12-30_89_9: 8 starts (results)
2026-01-11 00:08:21,029 - INFO -   Race 2025-12-30_89_10: 11 starts (results)
2026-01-11 00:08:21,039 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:08:21,194 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:08:21,194 - INFO - Found V85 game: V85_2025-12-30_78_3 with 8 races
2026-01-11 00:08:21,194 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:08:21,194 - INFO - Fetching calendar for 2025-12-30
2026-01-11 00:08:21,340 - INFO - Found 6 tracks for 2025-12-30
2026-01-11 00:08:21,841 - INFO - Processing track: Bjerke
2026-01-11 00:08:22,496 - INFO -   Race 2025-12-30_78_1: 7 starts (results)
2026-01-11 00:08:23,168 - INFO -   Race 2025-12-30_78_2: 10 starts (results)
2026-01-11 00:08:23,823 - INFO -   Race 2025-12-30_78_3: 11 starts (results)
2026-01-11 00:08:24,484 - INFO -   Race 2025-12-30_78_4: 11 starts (results)
2026-01-11 00:08:25,154 - INFO -   Race 2025-12-30_78_5: 12 starts (results)
2026-01-11 00:08:25,830 - INFO -   Race 2025-12-30_78_6: 9 starts (results)
2026-01-11 00:08:26,495 - INFO -   Race 2025-12-30_78_7: 12 starts (results)
2026-01-11 00:08:27,149 - INFO -   Race 2025-12-30_78_8: 12 starts (results)
2026-01-11 00:08:27,814 - INFO -   Race 2025-12-30_78_9: 9 starts (results)
2026-01-11 00:08:28,470 - INFO -   Race 2025-12-30_78_10: 12 starts (results)
2026-01-11 00:08:28,470 - INFO - Processing track: Charlottenlund
2026-01-11 00:08:29,140 - INFO -   Race 2025-12-30_55_1: 10 starts (results)
2026-01-11 00:08:29,795 - INFO -   Race 2025-12-30_55_2: 11 starts (results)
2026-01-11 00:08:30,453 - INFO -   Race 2025-12-30_55_3: 13 starts (results)
2026-01-11 00:08:31,102 - INFO -   Race 2025-12-30_55_4: 11 starts (results)
2026-01-11 00:08:31,865 - INFO -   Race 2025-12-30_55_5: 10 starts (results)
2026-01-11 00:08:32,513 - INFO -   Race 2025-12-30_55_6: 9 starts (results)
2026-01-11 00:08:33,170 - INFO -   Race 2025-12-30_55_7: 9 starts (results)
2026-01-11 00:08:33,832 - INFO -   Race 2025-12-30_55_8: 10 starts (results)
2026-01-11 00:08:34,490 - INFO -   Race 2025-12-30_55_9: 10 starts (results)
2026-01-11 00:08:34,490 - INFO - Processing track: Boden
2026-01-11 00:08:35,171 - INFO -   Race 2025-12-30_11_1: 12 starts (results)
2026-01-11 00:08:35,839 - INFO -   Race 2025-12-30_11_2: 13 starts (results)
2026-01-11 00:08:36,498 - INFO -   Race 2025-12-30_11_3: 12 starts (results)
2026-01-11 00:08:37,152 - INFO -   Race 2025-12-30_11_4: 12 starts (results)
2026-01-11 00:08:37,818 - INFO -   Race 2025-12-30_11_5: 8 starts (results)
2026-01-11 00:08:38,478 - INFO -   Race 2025-12-30_11_6: 13 starts (results)
2026-01-11 00:08:39,145 - INFO -   Race 2025-12-30_11_7: 15 starts (results)
2026-01-11 00:08:39,820 - INFO -   Race 2025-12-30_11_8: 11 starts (results)
2026-01-11 00:08:40,475 - INFO -   Race 2025-12-30_11_9: 15 starts (results)
2026-01-11 00:08:40,475 - INFO - Processing track: Mantorp
2026-01-11 00:08:41,133 - INFO -   Race 2025-12-30_22_1: 12 starts (results)
2026-01-11 00:08:41,796 - INFO -   Race 2025-12-30_22_2: 12 starts (results)
2026-01-11 00:08:42,456 - INFO -   Race 2025-12-30_22_3: 15 starts (results)
2026-01-11 00:08:43,128 - INFO -   Race 2025-12-30_22_4: 12 starts (results)
2026-01-11 00:08:43,805 - INFO -   Race 2025-12-30_22_5: 12 starts (results)
2026-01-11 00:08:44,485 - INFO -   Race 2025-12-30_22_6: 12 starts (results)
2026-01-11 00:08:45,135 - INFO -   Race 2025-12-30_22_7: 12 starts (results)
2026-01-11 00:08:45,809 - INFO -   Race 2025-12-30_22_8: 12 starts (results)
2026-01-11 00:08:45,809 - INFO - Processing track: Vincennes
2026-01-11 00:08:46,489 - INFO -   Race 2025-12-30_63_1: 11 starts (results)
2026-01-11 00:08:47,150 - INFO -   Race 2025-12-30_63_2: 11 starts (results)
2026-01-11 00:08:47,791 - INFO -   Race 2025-12-30_63_3: 13 starts (results)
2026-01-11 00:08:48,448 - INFO -   Race 2025-12-30_63_4: 12 starts (results)
2026-01-11 00:08:49,097 - INFO -   Race 2025-12-30_63_5: 11 starts (results)
2026-01-11 00:08:49,753 - INFO -   Race 2025-12-30_63_6: 16 starts (results)
2026-01-11 00:08:50,412 - INFO -   Race 2025-12-30_63_7: 10 starts (results)
2026-01-11 00:08:51,069 - INFO -   Race 2025-12-30_63_8: 14 starts (results)
2026-01-11 00:08:51,070 - INFO - Processing track: Turffontein
2026-01-11 00:08:51,734 - INFO -   Race 2025-12-30_89_1: 9 starts (results)
2026-01-11 00:08:52,395 - INFO -   Race 2025-12-30_89_2: 8 starts (results)
2026-01-11 00:08:53,051 - INFO -   Race 2025-12-30_89_3: 9 starts (results)
2026-01-11 00:08:53,733 - INFO -   Race 2025-12-30_89_4: 9 starts (results)
2026-01-11 00:08:54,412 - INFO -   Race 2025-12-30_89_5: 10 starts (results)
2026-01-11 00:08:55,065 - INFO -   Race 2025-12-30_89_6: 6 starts (results)
2026-01-11 00:08:55,726 - INFO -   Race 2025-12-30_89_7: 6 starts (results)
2026-01-11 00:08:56,382 - INFO -   Race 2025-12-30_89_8: 9 starts (results)
2026-01-11 00:08:57,041 - INFO -   Race 2025-12-30_89_9: 8 starts (results)
2026-01-11 00:08:57,771 - INFO -   Race 2025-12-30_89_10: 11 starts (results)
2026-01-11 00:08:57,780 - INFO - Fetching V85 races for 2025-12-29
2026-01-11 00:08:57,780 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:08:58,604 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:08:58,604 - INFO - Found V85 game: V85_2025-12-29_54_3 with 8 races
2026-01-11 00:08:58,604 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:08:58,605 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:08:58,753 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:08:59,253 - INFO - Processing track: Skive
2026-01-11 00:08:59,962 - INFO -   Race 2025-12-29_54_1: 12 starts (results)
2026-01-11 00:09:00,652 - INFO -   Race 2025-12-29_54_2: 5 starts (results)
2026-01-11 00:09:01,316 - INFO -   Race 2025-12-29_54_3: 9 starts (results)
2026-01-11 00:09:01,978 - INFO -   Race 2025-12-29_54_4: 12 starts (results)
2026-01-11 00:09:02,636 - INFO -   Race 2025-12-29_54_5: 12 starts (results)
2026-01-11 00:09:03,301 - INFO -   Race 2025-12-29_54_6: 7 starts (results)
2026-01-11 00:09:03,958 - INFO -   Race 2025-12-29_54_7: 12 starts (results)
2026-01-11 00:09:04,620 - INFO -   Race 2025-12-29_54_8: 12 starts (results)
2026-01-11 00:09:05,272 - INFO -   Race 2025-12-29_54_9: 12 starts (results)
2026-01-11 00:09:05,936 - INFO -   Race 2025-12-29_54_10: 15 starts (results)
2026-01-11 00:09:05,936 - INFO - Processing track: Bergen
2026-01-11 00:09:06,632 - INFO -   Race 2025-12-29_77_1: 8 starts (results)
2026-01-11 00:09:07,292 - INFO -   Race 2025-12-29_77_2: 10 starts (results)
2026-01-11 00:09:07,951 - INFO -   Race 2025-12-29_77_3: 10 starts (results)
2026-01-11 00:09:08,611 - INFO -   Race 2025-12-29_77_4: 7 starts (results)
2026-01-11 00:09:09,265 - INFO -   Race 2025-12-29_77_5: 15 starts (results)
2026-01-11 00:09:09,921 - INFO -   Race 2025-12-29_77_6: 11 starts (results)
2026-01-11 00:09:10,588 - INFO -   Race 2025-12-29_77_7: 11 starts (results)
2026-01-11 00:09:11,279 - INFO -   Race 2025-12-29_77_8: 10 starts (results)
2026-01-11 00:09:12,001 - INFO -   Race 2025-12-29_77_9: 8 starts (results)
2026-01-11 00:09:12,001 - INFO - Processing track: Romme
2026-01-11 00:09:12,711 - INFO -   Race 2025-12-29_23_1: 12 starts (results)
2026-01-11 00:09:13,413 - INFO -   Race 2025-12-29_23_2: 12 starts (results)
2026-01-11 00:09:14,138 - INFO -   Race 2025-12-29_23_3: 12 starts (results)
2026-01-11 00:09:14,835 - INFO -   Race 2025-12-29_23_4: 15 starts (results)
2026-01-11 00:09:15,543 - INFO -   Race 2025-12-29_23_5: 12 starts (results)
2026-01-11 00:09:16,270 - INFO -   Race 2025-12-29_23_6: 12 starts (results)
2026-01-11 00:09:16,962 - INFO -   Race 2025-12-29_23_7: 12 starts (results)
2026-01-11 00:09:17,735 - INFO -   Race 2025-12-29_23_8: 11 starts (results)
2026-01-11 00:09:18,457 - INFO -   Race 2025-12-29_23_9: 10 starts (results)
2026-01-11 00:09:19,151 - INFO -   Race 2025-12-29_23_10: 12 starts (results)
2026-01-11 00:09:19,151 - INFO - Processing track: Vincennes
2026-01-11 00:09:19,857 - INFO -   Race 2025-12-29_63_1: 13 starts (results)
2026-01-11 00:09:20,550 - INFO -   Race 2025-12-29_63_2: 13 starts (results)
2026-01-11 00:09:21,247 - INFO -   Race 2025-12-29_63_3: 13 starts (results)
2026-01-11 00:09:21,946 - INFO -   Race 2025-12-29_63_4: 7 starts (results)
2026-01-11 00:09:22,639 - INFO -   Race 2025-12-29_63_5: 9 starts (results)
2026-01-11 00:09:23,339 - INFO -   Race 2025-12-29_63_6: 16 starts (results)
2026-01-11 00:09:24,038 - INFO -   Race 2025-12-29_63_7: 11 starts (results)
2026-01-11 00:09:24,739 - INFO -   Race 2025-12-29_63_8: 13 starts (results)
2026-01-11 00:09:24,739 - INFO - Processing track: Fairview
2026-01-11 00:09:25,420 - INFO -   Race 2025-12-29_89_1: 8 starts (results)
2026-01-11 00:09:26,134 - INFO -   Race 2025-12-29_89_2: 9 starts (results)
2026-01-11 00:09:26,815 - INFO -   Race 2025-12-29_89_3: 11 starts (results)
2026-01-11 00:09:27,507 - INFO -   Race 2025-12-29_89_4: 9 starts (results)
2026-01-11 00:09:28,207 - INFO -   Race 2025-12-29_89_5: 12 starts (results)
2026-01-11 00:09:28,896 - INFO -   Race 2025-12-29_89_6: 9 starts (results)
2026-01-11 00:09:29,588 - INFO -   Race 2025-12-29_89_7: 10 starts (results)
2026-01-11 00:09:30,278 - INFO -   Race 2025-12-29_89_8: 12 starts (results)
2026-01-11 00:09:30,282 - INFO - V85 Game: V85_2025-12-29_54_3
2026-01-11 00:09:30,282 - INFO - Loaded 91 horses from 8 V85 races
2026-01-11 00:09:30,282 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:09:30,282 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:09:30,284 - INFO - Added temporal features
2026-01-11 00:09:30,285 - INFO - Added post position features
2026-01-11 00:09:30,286 - INFO - Calculated driver/trainer rates
2026-01-11 00:09:30,286 - INFO - Added speed features
2026-01-11 00:09:30,286 - INFO - Added track importance features
2026-01-11 00:09:30,288 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:09:30,444 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:09:31,467 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:09:31,467 - INFO - Found V85 game: V85_2025-12-29_54_3 with 8 races
2026-01-11 00:09:31,467 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:09:31,467 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:09:31,634 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:09:32,134 - INFO - Processing track: Skive
2026-01-11 00:09:32,896 - INFO -   Race 2025-12-29_54_1: 12 starts (results)
2026-01-11 00:09:33,612 - INFO -   Race 2025-12-29_54_2: 5 starts (results)
2026-01-11 00:09:34,278 - INFO -   Race 2025-12-29_54_3: 9 starts (results)
2026-01-11 00:09:34,939 - INFO -   Race 2025-12-29_54_4: 12 starts (results)
2026-01-11 00:09:35,590 - INFO -   Race 2025-12-29_54_5: 12 starts (results)
2026-01-11 00:09:36,241 - INFO -   Race 2025-12-29_54_6: 7 starts (results)
2026-01-11 00:09:36,892 - INFO -   Race 2025-12-29_54_7: 12 starts (results)
2026-01-11 00:09:37,605 - INFO -   Race 2025-12-29_54_8: 12 starts (results)
2026-01-11 00:09:38,275 - INFO -   Race 2025-12-29_54_9: 12 starts (results)
2026-01-11 00:09:38,942 - INFO -   Race 2025-12-29_54_10: 15 starts (results)
2026-01-11 00:09:38,942 - INFO - Processing track: Bergen
2026-01-11 00:09:39,594 - INFO -   Race 2025-12-29_77_1: 8 starts (results)
2026-01-11 00:09:40,270 - INFO -   Race 2025-12-29_77_2: 10 starts (results)
2026-01-11 00:09:40,932 - INFO -   Race 2025-12-29_77_3: 10 starts (results)
2026-01-11 00:09:41,632 - INFO -   Race 2025-12-29_77_4: 7 starts (results)
2026-01-11 00:09:42,294 - INFO -   Race 2025-12-29_77_5: 15 starts (results)
2026-01-11 00:09:42,953 - INFO -   Race 2025-12-29_77_6: 11 starts (results)
2026-01-11 00:09:43,629 - INFO -   Race 2025-12-29_77_7: 11 starts (results)
2026-01-11 00:09:44,320 - INFO -   Race 2025-12-29_77_8: 10 starts (results)
2026-01-11 00:09:44,966 - INFO -   Race 2025-12-29_77_9: 8 starts (results)
2026-01-11 00:09:44,966 - INFO - Processing track: Romme
2026-01-11 00:09:45,695 - INFO -   Race 2025-12-29_23_1: 12 starts (results)
2026-01-11 00:09:46,364 - INFO -   Race 2025-12-29_23_2: 12 starts (results)
2026-01-11 00:09:47,040 - INFO -   Race 2025-12-29_23_3: 12 starts (results)
2026-01-11 00:09:47,706 - INFO -   Race 2025-12-29_23_4: 15 starts (results)
2026-01-11 00:09:48,392 - INFO -   Race 2025-12-29_23_5: 12 starts (results)
2026-01-11 00:09:49,078 - INFO -   Race 2025-12-29_23_6: 12 starts (results)
2026-01-11 00:09:49,756 - INFO -   Race 2025-12-29_23_7: 12 starts (results)
2026-01-11 00:09:50,410 - INFO -   Race 2025-12-29_23_8: 11 starts (results)
2026-01-11 00:09:51,068 - INFO -   Race 2025-12-29_23_9: 10 starts (results)
2026-01-11 00:09:51,740 - INFO -   Race 2025-12-29_23_10: 12 starts (results)
2026-01-11 00:09:51,740 - INFO - Processing track: Vincennes
2026-01-11 00:09:52,411 - INFO -   Race 2025-12-29_63_1: 13 starts (results)
2026-01-11 00:09:53,083 - INFO -   Race 2025-12-29_63_2: 13 starts (results)
2026-01-11 00:09:53,728 - INFO -   Race 2025-12-29_63_3: 13 starts (results)
2026-01-11 00:09:54,387 - INFO -   Race 2025-12-29_63_4: 7 starts (results)
2026-01-11 00:09:55,074 - INFO -   Race 2025-12-29_63_5: 9 starts (results)
2026-01-11 00:09:55,745 - INFO -   Race 2025-12-29_63_6: 16 starts (results)
2026-01-11 00:09:56,441 - INFO -   Race 2025-12-29_63_7: 11 starts (results)
2026-01-11 00:09:57,107 - INFO -   Race 2025-12-29_63_8: 13 starts (results)
2026-01-11 00:09:57,107 - INFO - Processing track: Fairview
2026-01-11 00:09:57,780 - INFO -   Race 2025-12-29_89_1: 8 starts (results)
2026-01-11 00:09:58,446 - INFO -   Race 2025-12-29_89_2: 9 starts (results)
2026-01-11 00:09:59,212 - INFO -   Race 2025-12-29_89_3: 11 starts (results)
2026-01-11 00:09:59,928 - INFO -   Race 2025-12-29_89_4: 9 starts (results)
2026-01-11 00:10:00,628 - INFO -   Race 2025-12-29_89_5: 12 starts (results)
2026-01-11 00:10:01,306 - INFO -   Race 2025-12-29_89_6: 9 starts (results)
2026-01-11 00:10:01,961 - INFO -   Race 2025-12-29_89_7: 10 starts (results)
2026-01-11 00:10:02,627 - INFO -   Race 2025-12-29_89_8: 12 starts (results)
2026-01-11 00:10:02,637 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:10:02,809 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:10:02,809 - INFO - Found V85 game: V85_2025-12-29_54_3 with 8 races
2026-01-11 00:10:02,809 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:10:02,809 - INFO - Fetching calendar for 2025-12-29
2026-01-11 00:10:02,975 - INFO - Found 5 tracks for 2025-12-29
2026-01-11 00:10:03,476 - INFO - Processing track: Skive
2026-01-11 00:10:04,130 - INFO -   Race 2025-12-29_54_1: 12 starts (results)
2026-01-11 00:10:04,775 - INFO -   Race 2025-12-29_54_2: 5 starts (results)
2026-01-11 00:10:05,431 - INFO -   Race 2025-12-29_54_3: 9 starts (results)
2026-01-11 00:10:06,094 - INFO -   Race 2025-12-29_54_4: 12 starts (results)
2026-01-11 00:10:06,767 - INFO -   Race 2025-12-29_54_5: 12 starts (results)
2026-01-11 00:10:07,439 - INFO -   Race 2025-12-29_54_6: 7 starts (results)
2026-01-11 00:10:08,102 - INFO -   Race 2025-12-29_54_7: 12 starts (results)
2026-01-11 00:10:08,761 - INFO -   Race 2025-12-29_54_8: 12 starts (results)
2026-01-11 00:10:09,417 - INFO -   Race 2025-12-29_54_9: 12 starts (results)
2026-01-11 00:10:10,059 - INFO -   Race 2025-12-29_54_10: 15 starts (results)
2026-01-11 00:10:10,059 - INFO - Processing track: Bergen
2026-01-11 00:10:10,703 - INFO -   Race 2025-12-29_77_1: 8 starts (results)
2026-01-11 00:10:11,352 - INFO -   Race 2025-12-29_77_2: 10 starts (results)
2026-01-11 00:10:12,008 - INFO -   Race 2025-12-29_77_3: 10 starts (results)
2026-01-11 00:10:12,669 - INFO -   Race 2025-12-29_77_4: 7 starts (results)
2026-01-11 00:10:13,340 - INFO -   Race 2025-12-29_77_5: 15 starts (results)
2026-01-11 00:10:14,013 - INFO -   Race 2025-12-29_77_6: 11 starts (results)
2026-01-11 00:10:14,670 - INFO -   Race 2025-12-29_77_7: 11 starts (results)
2026-01-11 00:10:15,312 - INFO -   Race 2025-12-29_77_8: 10 starts (results)
2026-01-11 00:10:15,984 - INFO -   Race 2025-12-29_77_9: 8 starts (results)
2026-01-11 00:10:15,984 - INFO - Processing track: Romme
2026-01-11 00:10:16,646 - INFO -   Race 2025-12-29_23_1: 12 starts (results)
2026-01-11 00:10:17,307 - INFO -   Race 2025-12-29_23_2: 12 starts (results)
2026-01-11 00:10:17,972 - INFO -   Race 2025-12-29_23_3: 12 starts (results)
2026-01-11 00:10:18,633 - INFO -   Race 2025-12-29_23_4: 15 starts (results)
2026-01-11 00:10:19,291 - INFO -   Race 2025-12-29_23_5: 12 starts (results)
2026-01-11 00:10:19,961 - INFO -   Race 2025-12-29_23_6: 12 starts (results)
2026-01-11 00:10:20,617 - INFO -   Race 2025-12-29_23_7: 12 starts (results)
2026-01-11 00:10:21,274 - INFO -   Race 2025-12-29_23_8: 11 starts (results)
2026-01-11 00:10:21,958 - INFO -   Race 2025-12-29_23_9: 10 starts (results)
2026-01-11 00:10:22,625 - INFO -   Race 2025-12-29_23_10: 12 starts (results)
2026-01-11 00:10:22,625 - INFO - Processing track: Vincennes
2026-01-11 00:10:23,435 - INFO -   Race 2025-12-29_63_1: 13 starts (results)
2026-01-11 00:10:24,301 - INFO -   Race 2025-12-29_63_2: 13 starts (results)
2026-01-11 00:10:24,955 - INFO -   Race 2025-12-29_63_3: 13 starts (results)
2026-01-11 00:10:25,634 - INFO -   Race 2025-12-29_63_4: 7 starts (results)
2026-01-11 00:10:26,294 - INFO -   Race 2025-12-29_63_5: 9 starts (results)
2026-01-11 00:10:26,952 - INFO -   Race 2025-12-29_63_6: 16 starts (results)
2026-01-11 00:10:27,607 - INFO -   Race 2025-12-29_63_7: 11 starts (results)
2026-01-11 00:10:28,268 - INFO -   Race 2025-12-29_63_8: 13 starts (results)
2026-01-11 00:10:28,268 - INFO - Processing track: Fairview
2026-01-11 00:10:28,922 - INFO -   Race 2025-12-29_89_1: 8 starts (results)
2026-01-11 00:10:29,583 - INFO -   Race 2025-12-29_89_2: 9 starts (results)
2026-01-11 00:10:30,253 - INFO -   Race 2025-12-29_89_3: 11 starts (results)
2026-01-11 00:10:30,916 - INFO -   Race 2025-12-29_89_4: 9 starts (results)
2026-01-11 00:10:31,561 - INFO -   Race 2025-12-29_89_5: 12 starts (results)
2026-01-11 00:10:32,228 - INFO -   Race 2025-12-29_89_6: 9 starts (results)
2026-01-11 00:10:32,894 - INFO -   Race 2025-12-29_89_7: 10 starts (results)
2026-01-11 00:10:33,949 - INFO -   Race 2025-12-29_89_8: 12 starts (results)

================================================================================
V85 SYSTEM vs INDIVIDUAL BETTING COMPARISON
USING TEMPORAL MODEL (No Data Leakage)
Budget: 1000 SEK per V85 race
Testing last 10 V85 races
================================================================================

🔍 Searching for V85 races in last 90 days...
  ✓ Found V85 on 2026-01-10 (results)
  ✓ Found V85 on 2026-01-03 (results)
  ✓ Found V85 on 2025-12-31 (results)
  ✓ Found V85 on 2025-12-30 (results)
  ✓ Found V85 on 2025-12-29 (results)
  ✓ Found V85 on 2025-12-28 (results)
  ✓ Found V85 on 2025-12-27 (results)
  ✓ Found V85 on 2025-12-26 (results)
  ✓ Found V85 on 2025-12-25 (results)
  ✓ Found V85 on 2025-12-23 (results)
  ✓ Found V85 on 2025-12-20 (results)
  ✓ Found V85 on 2025-12-13 (results)
  ✓ Found V85 on 2025-12-06 (results)
  ✓ Found V85 on 2025-11-29 (results)
  ✓ Found V85 on 2025-11-22 (results)
  ✓ Found V85 on 2025-11-15 (results)
  ✓ Found V85 on 2025-11-08 (results)
  ✓ Found V85 on 2025-11-02 (results)
  ✓ Found V85 on 2025-11-01 (results)
  ✓ Found V85 on 2025-10-25 (results)

Testing 10 V85 races:
  - 2026-01-10
  - 2026-01-03
  - 2025-12-31
  - 2025-12-30
  - 2025-12-29
  - 2025-12-28
  - 2025-12-27
  - 2025-12-26
  - 2025-12-25
  - 2025-12-23

================================================================================
Testing 2026-01-10
================================================================================

🎯 Winning combination: 2-3-2-7-1-5-10-2

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: PLACE on Grådö Bo (121 SEK @ 20.8 odds)
  ✅ V85 Race 2: PLACE on Nephtys Boko (118 SEK @ 2.3 odds) → 180 SEK
  ❌ V85 Race 3: PLACE on Mandragora (122 SEK @ 41.5 odds)
  ✅ V85 Race 4: WIN on Karat River (153 SEK @ 5.8 odds) → 879 SEK
  ✅ V85 Race 5: PLACE on Hankypanky Slander (123 SEK @ 33.3 odds) → 1708 SEK
  ❌ V85 Race 6: PLACE on Light In (130 SEK @ 15.8 odds)
  ✅ V85 Race 7: PLACE on Tangelo (127 SEK @ 17.6 odds) → 970 SEK
  ❌ V85 Race 8: PLACE on Dahlia Brodda (106 SEK @ 39.2 odds)

Total bet: 1000 SEK
Total payout: 3738 SEK
Profit: +2738 SEK (+273.8% ROI)
Win rate: 4/8 (50.0%)

================================================================================
Testing 2026-01-03
================================================================================

🎯 Winning combination: 1-5-1-1-1-3-12-1

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 7 bets:
  ✅ V85 Race 1: PLACE on Global Gaiety (140 SEK @ 3.0 odds) → 252 SEK
  ✅ V85 Race 2: PLACE on Esperia Font (167 SEK @ 3.9 odds) → 361 SEK
  ❌ V85 Race 3: PLACE on Nordic In (141 SEK @ 9.0 odds)
  ✅ V85 Race 4: PLACE on Stens Rubin (155 SEK @ 1.2 odds) → 166 SEK
  ✅ V85 Race 6: PLACE on Matti Ruisma (135 SEK @ 2.4 odds) → 209 SEK
  ❌ V85 Race 7: PLACE on Summit Diablo (137 SEK @ 25.1 odds)
  ✅ V85 Race 8: PLACE on Eminent Kronos (124 SEK @ 1.9 odds) → 168 SEK

Total bet: 1000 SEK
Total payout: 1155 SEK
Profit: +155 SEK (+15.5% ROI)
Win rate: 5/7 (71.4%)

================================================================================
Testing 2025-12-31
================================================================================

🎯 Winning combination: 1-12-11-10-7-11-6-1

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Five Bring Joy (114 SEK @ 30.9 odds)
  ❌ V85 Race 2: WIN on J.Kagan Brick (129 SEK @ 2.1 odds)
  ❌ V85 Race 3: WIN on Carmita Silvio (118 SEK @ 11.2 odds)
  ❌ V85 Race 4: WIN on Woo Doo Doo Art (120 SEK @ 9.2 odds)
  ❌ V85 Race 5: WIN on Remy Lane (133 SEK @ 4.1 odds)
  ❌ V85 Race 6: WIN on Vamos Flax (129 SEK @ 3.9 odds)
  ❌ V85 Race 7: WIN on Assar Rapid (137 SEK @ 16.5 odds)
  ❌ V85 Race 8: WIN on Mister Garrincha (120 SEK @ 57.1 odds)

Total bet: 1000 SEK
Total payout: 0 SEK
Profit: -1000 SEK (-100.0% ROI)
Win rate: 0/8 (0.0%)

================================================================================
Testing 2025-12-30
================================================================================

🎯 Winning combination: 7-5-3-3-10-4-5-5

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-3-3-2-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ✅ V85 Race 1: WIN on Alunita (147 SEK @ 87.9 odds) → 12875 SEK
  ❌ V85 Race 2: WIN on Sjø Sara (108 SEK @ 11.5 odds)
  ❌ V85 Race 3: WIN on Bully Pepper (118 SEK @ 5.8 odds)
  ❌ V85 Race 4: WIN on Senorita (144 SEK @ 21.9 odds)
  ❌ V85 Race 5: WIN on Arya Star (117 SEK @ 47.6 odds)
  ✅ V85 Race 6: WIN on Nytomt Amira (111 SEK @ 3.3 odds) → 364 SEK
  ❌ V85 Race 7: WIN on Don't Say Gar (146 SEK @ 14.3 odds)
  ❌ V85 Race 8: WIN on Karlsson N.O. (110 SEK @ 9.1 odds)

Total bet: 1000 SEK
Total payout: 13239 SEK
Profit: +12239 SEK (+1223.9% ROI)
Win rate: 2/8 (25.0%)

================================================================================
Testing 2025-12-29
================================================================================

🎯 Winning combination: 1-3-5-7-8-8-6-12

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Keep Up Laser (142 SEK @ 18.5 odds)
  ✅ V85 Race 2: PLACE on Kandis Spring (84 SEK @ 6.4 odds) → 265 SEK
  ✅ V85 Race 3: PLACE on Kopper Dust (115 SEK @ 7.0 odds) → 388 SEK
  ❌ V85 Race 4: WIN on Harboe (145 SEK @ 20.7 odds)
  ❌ V85 Race 5: WIN on Pebbles Stone (140 SEK @ 0.0 odds)
  ❌ V85 Race 6: WIN on Initus (131 SEK @ 53.0 odds)
  ❌ V85 Race 7: WIN on Forest Jet (136 SEK @ 2.1 odds)
  ❌ V85 Race 8: PLACE on Manhattan Trot (106 SEK @ 108.4 odds)

Total bet: 1000 SEK
Total payout: 653 SEK
Profit: -347 SEK (-34.7% ROI)
Win rate: 2/8 (25.0%)

================================================================================2026-01-11 00:10:33,957 - INFO - Fetching V85 races for 2025-12-28
2026-01-11 00:10:33,957 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:10:35,269 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:10:35,269 - INFO - Found V85 game: V85_2025-12-28_80_3 with 8 races
2026-01-11 00:10:35,269 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:10:35,269 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:10:35,419 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:10:35,919 - INFO - Processing track: Momarken
2026-01-11 00:10:36,618 - INFO -   Race 2025-12-28_80_1: 12 starts (results)
2026-01-11 00:10:37,301 - INFO -   Race 2025-12-28_80_2: 8 starts (results)
2026-01-11 00:10:37,975 - INFO -   Race 2025-12-28_80_3: 11 starts (results)
2026-01-11 00:10:38,655 - INFO -   Race 2025-12-28_80_4: 13 starts (results)
2026-01-11 00:10:39,348 - INFO -   Race 2025-12-28_80_5: 9 starts (results)
2026-01-11 00:10:40,055 - INFO -   Race 2025-12-28_80_6: 10 starts (results)
2026-01-11 00:10:40,739 - INFO -   Race 2025-12-28_80_7: 12 starts (results)
2026-01-11 00:10:41,404 - INFO -   Race 2025-12-28_80_8: 12 starts (results)
2026-01-11 00:10:42,072 - INFO -   Race 2025-12-28_80_9: 12 starts (results)
2026-01-11 00:10:42,745 - INFO -   Race 2025-12-28_80_10: 15 starts (results)
2026-01-11 00:10:42,745 - INFO - Processing track: Bergsåker
2026-01-11 00:10:43,430 - INFO -   Race 2025-12-28_9_1: 12 starts (results)
2026-01-11 00:10:44,151 - INFO -   Race 2025-12-28_9_2: 11 starts (results)
2026-01-11 00:10:44,809 - INFO -   Race 2025-12-28_9_3: 12 starts (results)
2026-01-11 00:10:45,600 - INFO -   Race 2025-12-28_9_4: 15 starts (results)
2026-01-11 00:10:46,251 - INFO -   Race 2025-12-28_9_5: 12 starts (results)
2026-01-11 00:10:46,953 - INFO -   Race 2025-12-28_9_6: 12 starts (results)
2026-01-11 00:10:47,657 - INFO -   Race 2025-12-28_9_7: 15 starts (results)
2026-01-11 00:10:48,349 - INFO -   Race 2025-12-28_9_8: 12 starts (results)
2026-01-11 00:10:48,995 - INFO -   Race 2025-12-28_9_9: 12 starts (results)
2026-01-11 00:10:49,698 - INFO -   Race 2025-12-28_9_10: 12 starts (results)
2026-01-11 00:10:49,698 - INFO - Processing track: Vincennes
2026-01-11 00:10:50,392 - INFO -   Race 2025-12-28_63_1: 16 starts (results)
2026-01-11 00:10:51,076 - INFO -   Race 2025-12-28_63_2: 9 starts (results)
2026-01-11 00:10:51,754 - INFO -   Race 2025-12-28_63_3: 10 starts (results)
2026-01-11 00:10:52,458 - INFO -   Race 2025-12-28_63_4: 16 starts (results)
2026-01-11 00:10:53,148 - INFO -   Race 2025-12-28_63_5: 16 starts (results)
2026-01-11 00:10:53,837 - INFO -   Race 2025-12-28_63_6: 16 starts (results)
2026-01-11 00:10:54,519 - INFO -   Race 2025-12-28_63_7: 16 starts (results)
2026-01-11 00:10:55,208 - INFO -   Race 2025-12-28_63_8: 16 starts (results)
2026-01-11 00:10:55,883 - INFO -   Race 2025-12-28_63_9: 9 starts (results)
2026-01-11 00:10:55,883 - INFO - Processing track: Gulfstream Park
2026-01-11 00:10:56,568 - INFO -   Race 2025-12-28_97_1: 13 starts (results)
2026-01-11 00:10:57,255 - INFO -   Race 2025-12-28_97_2: 9 starts (results)
2026-01-11 00:10:57,924 - INFO -   Race 2025-12-28_97_3: 8 starts (results)
2026-01-11 00:10:58,613 - INFO -   Race 2025-12-28_97_4: 7 starts (results)
2026-01-11 00:10:59,303 - INFO -   Race 2025-12-28_97_5: 8 starts (results)
2026-01-11 00:10:59,974 - INFO -   Race 2025-12-28_97_6: 9 starts (results)
2026-01-11 00:11:00,654 - INFO -   Race 2025-12-28_97_7: 8 starts (results)
2026-01-11 00:11:01,336 - INFO -   Race 2025-12-28_97_8: 8 starts (results)
2026-01-11 00:11:02,042 - INFO -   Race 2025-12-28_97_9: 7 starts (results)
2026-01-11 00:11:02,730 - INFO -   Race 2025-12-28_97_10: 9 starts (results)
2026-01-11 00:11:02,733 - INFO - V85 Game: V85_2025-12-28_80_3
2026-01-11 00:11:02,734 - INFO - Loaded 94 horses from 8 V85 races
2026-01-11 00:11:02,734 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:11:02,734 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:11:02,736 - INFO - Added temporal features
2026-01-11 00:11:02,736 - INFO - Added post position features
2026-01-11 00:11:02,737 - INFO - Calculated driver/trainer rates
2026-01-11 00:11:02,738 - INFO - Added speed features
2026-01-11 00:11:02,738 - INFO - Added track importance features
/home/per/Work/trav/api_data_processor.py:142: FutureWarning: The behavior of Index.insert with object-dtype is deprecated, in a future version this will return an object-dtype Index instead of inferring a non-object dtype. To retain the old behavior, do `idx.insert(loc, item).infer_objects(copy=False)`
  condition_dummies = pd.get_dummies(df['track_condition'], prefix='condition', dummy_na=True)
2026-01-11 00:11:02,740 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:11:02,899 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:11:03,993 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:11:03,993 - INFO - Found V85 game: V85_2025-12-28_80_3 with 8 races
2026-01-11 00:11:03,993 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:11:03,993 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:11:04,144 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:11:04,644 - INFO - Processing track: Momarken
2026-01-11 00:11:05,295 - INFO -   Race 2025-12-28_80_1: 12 starts (results)
2026-01-11 00:11:05,951 - INFO -   Race 2025-12-28_80_2: 8 starts (results)
2026-01-11 00:11:06,609 - INFO -   Race 2025-12-28_80_3: 11 starts (results)
2026-01-11 00:11:07,283 - INFO -   Race 2025-12-28_80_4: 13 starts (results)
2026-01-11 00:11:07,947 - INFO -   Race 2025-12-28_80_5: 9 starts (results)
2026-01-11 00:11:08,623 - INFO -   Race 2025-12-28_80_6: 10 starts (results)
2026-01-11 00:11:09,284 - INFO -   Race 2025-12-28_80_7: 12 starts (results)
2026-01-11 00:11:09,969 - INFO -   Race 2025-12-28_80_8: 12 starts (results)
2026-01-11 00:11:10,653 - INFO -   Race 2025-12-28_80_9: 12 starts (results)
2026-01-11 00:11:11,344 - INFO -   Race 2025-12-28_80_10: 15 starts (results)
2026-01-11 00:11:11,344 - INFO - Processing track: Bergsåker
2026-01-11 00:11:12,010 - INFO -   Race 2025-12-28_9_1: 12 starts (results)
2026-01-11 00:11:12,693 - INFO -   Race 2025-12-28_9_2: 11 starts (results)
2026-01-11 00:11:13,342 - INFO -   Race 2025-12-28_9_3: 12 starts (results)
2026-01-11 00:11:14,029 - INFO -   Race 2025-12-28_9_4: 15 starts (results)
2026-01-11 00:11:14,715 - INFO -   Race 2025-12-28_9_5: 12 starts (results)
2026-01-11 00:11:15,383 - INFO -   Race 2025-12-28_9_6: 12 starts (results)
2026-01-11 00:11:16,053 - INFO -   Race 2025-12-28_9_7: 15 starts (results)
2026-01-11 00:11:16,723 - INFO -   Race 2025-12-28_9_8: 12 starts (results)
2026-01-11 00:11:17,447 - INFO -   Race 2025-12-28_9_9: 12 starts (results)
2026-01-11 00:11:18,101 - INFO -   Race 2025-12-28_9_10: 12 starts (results)
2026-01-11 00:11:18,101 - INFO - Processing track: Vincennes
2026-01-11 00:11:18,955 - INFO -   Race 2025-12-28_63_1: 16 starts (results)
2026-01-11 00:11:19,612 - INFO -   Race 2025-12-28_63_2: 9 starts (results)
2026-01-11 00:11:20,288 - INFO -   Race 2025-12-28_63_3: 10 starts (results)
2026-01-11 00:11:20,941 - INFO -   Race 2025-12-28_63_4: 16 starts (results)
2026-01-11 00:11:21,606 - INFO -   Race 2025-12-28_63_5: 16 starts (results)
2026-01-11 00:11:22,263 - INFO -   Race 2025-12-28_63_6: 16 starts (results)
2026-01-11 00:11:22,932 - INFO -   Race 2025-12-28_63_7: 16 starts (results)
2026-01-11 00:11:23,600 - INFO -   Race 2025-12-28_63_8: 16 starts (results)
2026-01-11 00:11:24,285 - INFO -   Race 2025-12-28_63_9: 9 starts (results)
2026-01-11 00:11:24,285 - INFO - Processing track: Gulfstream Park
2026-01-11 00:11:24,950 - INFO -   Race 2025-12-28_97_1: 13 starts (results)
2026-01-11 00:11:25,627 - INFO -   Race 2025-12-28_97_2: 9 starts (results)
2026-01-11 00:11:26,288 - INFO -   Race 2025-12-28_97_3: 8 starts (results)
2026-01-11 00:11:26,959 - INFO -   Race 2025-12-28_97_4: 7 starts (results)
2026-01-11 00:11:27,615 - INFO -   Race 2025-12-28_97_5: 8 starts (results)
2026-01-11 00:11:28,270 - INFO -   Race 2025-12-28_97_6: 9 starts (results)
2026-01-11 00:11:28,936 - INFO -   Race 2025-12-28_97_7: 8 starts (results)
2026-01-11 00:11:29,601 - INFO -   Race 2025-12-28_97_8: 8 starts (results)
2026-01-11 00:11:30,262 - INFO -   Race 2025-12-28_97_9: 7 starts (results)
2026-01-11 00:11:30,937 - INFO -   Race 2025-12-28_97_10: 9 starts (results)
2026-01-11 00:11:30,946 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:11:31,101 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:11:31,101 - INFO - Found V85 game: V85_2025-12-28_80_3 with 8 races
2026-01-11 00:11:31,101 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:11:31,101 - INFO - Fetching calendar for 2025-12-28
2026-01-11 00:11:31,244 - INFO - Found 4 tracks for 2025-12-28
2026-01-11 00:11:31,744 - INFO - Processing track: Momarken
2026-01-11 00:11:32,394 - INFO -   Race 2025-12-28_80_1: 12 starts (results)
2026-01-11 00:11:33,041 - INFO -   Race 2025-12-28_80_2: 8 starts (results)
2026-01-11 00:11:33,696 - INFO -   Race 2025-12-28_80_3: 11 starts (results)
2026-01-11 00:11:34,369 - INFO -   Race 2025-12-28_80_4: 13 starts (results)
2026-01-11 00:11:35,041 - INFO -   Race 2025-12-28_80_5: 9 starts (results)
2026-01-11 00:11:35,687 - INFO -   Race 2025-12-28_80_6: 10 starts (results)
2026-01-11 00:11:36,721 - INFO -   Race 2025-12-28_80_7: 12 starts (results)
2026-01-11 00:11:37,380 - INFO -   Race 2025-12-28_80_8: 12 starts (results)
2026-01-11 00:11:38,055 - INFO -   Race 2025-12-28_80_9: 12 starts (results)
2026-01-11 00:11:38,716 - INFO -   Race 2025-12-28_80_10: 15 starts (results)
2026-01-11 00:11:38,716 - INFO - Processing track: Bergsåker
2026-01-11 00:11:39,380 - INFO -   Race 2025-12-28_9_1: 12 starts (results)
2026-01-11 00:11:40,057 - INFO -   Race 2025-12-28_9_2: 11 starts (results)
2026-01-11 00:11:40,715 - INFO -   Race 2025-12-28_9_3: 12 starts (results)
2026-01-11 00:11:41,377 - INFO -   Race 2025-12-28_9_4: 15 starts (results)
2026-01-11 00:11:42,059 - INFO -   Race 2025-12-28_9_5: 12 starts (results)
2026-01-11 00:11:42,731 - INFO -   Race 2025-12-28_9_6: 12 starts (results)
2026-01-11 00:11:43,387 - INFO -   Race 2025-12-28_9_7: 15 starts (results)
2026-01-11 00:11:44,035 - INFO -   Race 2025-12-28_9_8: 12 starts (results)
2026-01-11 00:11:44,689 - INFO -   Race 2025-12-28_9_9: 12 starts (results)
2026-01-11 00:11:45,402 - INFO -   Race 2025-12-28_9_10: 12 starts (results)
2026-01-11 00:11:45,402 - INFO - Processing track: Vincennes
2026-01-11 00:11:46,055 - INFO -   Race 2025-12-28_63_1: 16 starts (results)
2026-01-11 00:11:46,710 - INFO -   Race 2025-12-28_63_2: 9 starts (results)
2026-01-11 00:11:47,366 - INFO -   Race 2025-12-28_63_3: 10 starts (results)
2026-01-11 00:11:48,011 - INFO -   Race 2025-12-28_63_4: 16 starts (results)
2026-01-11 00:11:48,664 - INFO -   Race 2025-12-28_63_5: 16 starts (results)
2026-01-11 00:11:49,338 - INFO -   Race 2025-12-28_63_6: 16 starts (results)
2026-01-11 00:11:49,989 - INFO -   Race 2025-12-28_63_7: 16 starts (results)
2026-01-11 00:11:50,650 - INFO -   Race 2025-12-28_63_8: 16 starts (results)
2026-01-11 00:11:51,311 - INFO -   Race 2025-12-28_63_9: 9 starts (results)
2026-01-11 00:11:51,311 - INFO - Processing track: Gulfstream Park
2026-01-11 00:11:51,970 - INFO -   Race 2025-12-28_97_1: 13 starts (results)
2026-01-11 00:11:52,617 - INFO -   Race 2025-12-28_97_2: 9 starts (results)
2026-01-11 00:11:53,272 - INFO -   Race 2025-12-28_97_3: 8 starts (results)
2026-01-11 00:11:53,928 - INFO -   Race 2025-12-28_97_4: 7 starts (results)
2026-01-11 00:11:54,581 - INFO -   Race 2025-12-28_97_5: 8 starts (results)
2026-01-11 00:11:55,242 - INFO -   Race 2025-12-28_97_6: 9 starts (results)
2026-01-11 00:11:55,907 - INFO -   Race 2025-12-28_97_7: 8 starts (results)
2026-01-11 00:11:56,562 - INFO -   Race 2025-12-28_97_8: 8 starts (results)
2026-01-11 00:11:57,244 - INFO -   Race 2025-12-28_97_9: 7 starts (results)
2026-01-11 00:11:57,912 - INFO -   Race 2025-12-28_97_10: 9 starts (results)
2026-01-11 00:11:57,919 - INFO - Fetching V85 races for 2025-12-27
2026-01-11 00:11:57,919 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:11:58,916 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:11:58,916 - INFO - Found V85 game: V85_2025-12-27_16_3 with 8 races
2026-01-11 00:11:58,916 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:11:58,916 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:11:59,066 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:11:59,566 - INFO - Processing track: Gävle
2026-01-11 00:12:00,239 - INFO -   Race 2025-12-27_16_1: 15 starts (results)
2026-01-11 00:12:00,956 - INFO -   Race 2025-12-27_16_2: 8 starts (results)
2026-01-11 00:12:01,639 - INFO -   Race 2025-12-27_16_3: 12 starts (results)
2026-01-11 00:12:02,290 - INFO -   Race 2025-12-27_16_4: 11 starts (results)
2026-01-11 00:12:02,958 - INFO -   Race 2025-12-27_16_5: 15 starts (results)
2026-01-11 00:12:03,633 - INFO -   Race 2025-12-27_16_6: 12 starts (results)
2026-01-11 00:12:04,300 - INFO -   Race 2025-12-27_16_7: 15 starts (results)
2026-01-11 00:12:04,952 - INFO -   Race 2025-12-27_16_8: 15 starts (results)
2026-01-11 00:12:05,612 - INFO -   Race 2025-12-27_16_9: 12 starts (results)
2026-01-11 00:12:06,276 - INFO -   Race 2025-12-27_16_10: 12 starts (results)
2026-01-11 00:12:06,277 - INFO - Processing track: Orkla
2026-01-11 00:12:07,008 - INFO -   Race 2025-12-27_83_1: 8 starts (results)
2026-01-11 00:12:07,702 - INFO -   Race 2025-12-27_83_2: 9 starts (results)
2026-01-11 00:12:08,377 - INFO -   Race 2025-12-27_83_3: 11 starts (results)
2026-01-11 00:12:09,057 - INFO -   Race 2025-12-27_83_4: 12 starts (results)
2026-01-11 00:12:09,750 - INFO -   Race 2025-12-27_83_5: 10 starts (results)
2026-01-11 00:12:10,441 - INFO -   Race 2025-12-27_83_6: 12 starts (results)
2026-01-11 00:12:11,124 - INFO -   Race 2025-12-27_83_7: 12 starts (results)
2026-01-11 00:12:11,803 - INFO -   Race 2025-12-27_83_8: 11 starts (results)
2026-01-11 00:12:12,512 - INFO -   Race 2025-12-27_83_9: 8 starts (results)
2026-01-11 00:12:13,193 - INFO -   Race 2025-12-27_83_10: 7 starts (results)
2026-01-11 00:12:13,872 - INFO -   Race 2025-12-27_83_11: 8 starts (results)
2026-01-11 00:12:14,545 - INFO -   Race 2025-12-27_83_12: 10 starts (results)
2026-01-11 00:12:14,545 - INFO - Processing track: Vincennes
2026-01-11 00:12:15,227 - INFO -   Race 2025-12-27_63_1: 7 starts (results)
2026-01-11 00:12:15,930 - INFO -   Race 2025-12-27_63_2: 11 starts (results)
2026-01-11 00:12:16,604 - INFO -   Race 2025-12-27_63_3: 10 starts (results)
2026-01-11 00:12:17,293 - INFO -   Race 2025-12-27_63_4: 15 starts (results)
2026-01-11 00:12:17,975 - INFO -   Race 2025-12-27_63_5: 11 starts (results)
2026-01-11 00:12:18,689 - INFO -   Race 2025-12-27_63_6: 16 starts (results)
2026-01-11 00:12:19,365 - INFO -   Race 2025-12-27_63_7: 16 starts (results)
2026-01-11 00:12:20,077 - INFO -   Race 2025-12-27_63_8: 8 starts (results)
2026-01-11 00:12:20,751 - INFO -   Race 2025-12-27_63_9: 12 starts (results)
2026-01-11 00:12:20,751 - INFO - Processing track: Sha Tin
2026-01-11 00:12:21,466 - INFO -   Race 2025-12-27_68_1: 14 starts (results)
2026-01-11 00:12:22,153 - INFO -   Race 2025-12-27_68_2: 14 starts (results)
2026-01-11 00:12:22,832 - INFO -   Race 2025-12-27_68_3: 9 starts (results)
2026-01-11 00:12:23,561 - INFO -   Race 2025-12-27_68_4: 14 starts (results)
2026-01-11 00:12:24,262 - INFO -   Race 2025-12-27_68_5: 14 starts (results)
2026-01-11 00:12:24,959 - INFO -   Race 2025-12-27_68_6: 14 starts (results)
2026-01-11 00:12:25,665 - INFO -   Race 2025-12-27_68_7: 14 starts (results)
2026-01-11 00:12:26,352 - INFO -   Race 2025-12-27_68_8: 14 starts (results)
2026-01-11 00:12:27,051 - INFO -   Race 2025-12-27_68_9: 14 starts (results)
2026-01-11 00:12:27,736 - INFO -   Race 2025-12-27_68_10: 14 starts (results)
2026-01-11 00:12:27,736 - INFO - Processing track: Gulfstream Park
2026-01-11 00:12:28,459 - INFO -   Race 2025-12-27_97_1: 15 starts (results)
2026-01-11 00:12:29,128 - INFO -   Race 2025-12-27_97_2: 10 starts (results)
2026-01-11 00:12:29,805 - INFO -   Race 2025-12-27_97_3: 7 starts (results)
2026-01-11 00:12:30,518 - INFO -   Race 2025-12-27_97_4: 9 starts (results)
2026-01-11 00:12:31,200 - INFO -   Race 2025-12-27_97_5: 10 starts (results)
2026-01-11 00:12:31,912 - INFO -   Race 2025-12-27_97_6: 7 starts (results)
2026-01-11 00:12:32,600 - INFO -   Race 2025-12-27_97_7: 12 starts (results)
2026-01-11 00:12:33,277 - INFO -   Race 2025-12-27_97_8: 8 starts (results)
2026-01-11 00:12:33,962 - INFO -   Race 2025-12-27_97_9: 10 starts (results)
2026-01-11 00:12:34,646 - INFO -   Race 2025-12-27_97_10: 8 starts (results)
2026-01-11 00:12:35,326 - INFO -   Race 2025-12-27_97_11: 10 starts (results)
2026-01-11 00:12:35,330 - INFO - V85 Game: V85_2025-12-27_16_3
2026-01-11 00:12:35,330 - INFO - Loaded 104 horses from 8 V85 races
2026-01-11 00:12:35,330 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:12:35,330 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:12:35,332 - INFO - Added temporal features
2026-01-11 00:12:35,333 - INFO - Added post position features
2026-01-11 00:12:35,334 - INFO - Calculated driver/trainer rates
2026-01-11 00:12:35,334 - INFO - Added speed features
2026-01-11 00:12:35,335 - INFO - Added track importance features
2026-01-11 00:12:35,336 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:12:35,495 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:12:36,712 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:12:36,712 - INFO - Found V85 game: V85_2025-12-27_16_3 with 8 races
2026-01-11 00:12:36,712 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:12:36,712 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:12:36,862 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:12:37,363 - INFO - Processing track: Gävle
2026-01-11 00:12:38,036 - INFO -   Race 2025-12-27_16_1: 15 starts (results)
2026-01-11 00:12:38,701 - INFO -   Race 2025-12-27_16_2: 8 starts (results)
2026-01-11 00:12:39,365 - INFO -   Race 2025-12-27_16_3: 12 starts (results)
2026-01-11 00:12:40,042 - INFO -   Race 2025-12-27_16_4: 11 starts (results)
2026-01-11 00:12:40,801 - INFO -   Race 2025-12-27_16_5: 15 starts (results)
2026-01-11 00:12:41,463 - INFO -   Race 2025-12-27_16_6: 12 starts (results)
2026-01-11 00:12:42,129 - INFO -   Race 2025-12-27_16_7: 15 starts (results)
2026-01-11 00:12:42,848 - INFO -   Race 2025-12-27_16_8: 15 starts (results)
2026-01-11 00:12:43,569 - INFO -   Race 2025-12-27_16_9: 12 starts (results)
2026-01-11 00:12:44,231 - INFO -   Race 2025-12-27_16_10: 12 starts (results)
2026-01-11 00:12:44,231 - INFO - Processing track: Orkla
2026-01-11 00:12:44,894 - INFO -   Race 2025-12-27_83_1: 8 starts (results)
2026-01-11 00:12:45,560 - INFO -   Race 2025-12-27_83_2: 9 starts (results)
2026-01-11 00:12:46,209 - INFO -   Race 2025-12-27_83_3: 11 starts (results)
2026-01-11 00:12:46,888 - INFO -   Race 2025-12-27_83_4: 12 starts (results)
2026-01-11 00:12:47,555 - INFO -   Race 2025-12-27_83_5: 10 starts (results)
2026-01-11 00:12:48,222 - INFO -   Race 2025-12-27_83_6: 12 starts (results)
2026-01-11 00:12:48,884 - INFO -   Race 2025-12-27_83_7: 12 starts (results)
2026-01-11 00:12:49,548 - INFO -   Race 2025-12-27_83_8: 11 starts (results)
2026-01-11 00:12:50,219 - INFO -   Race 2025-12-27_83_9: 8 starts (results)
2026-01-11 00:12:50,879 - INFO -   Race 2025-12-27_83_10: 7 starts (results)
2026-01-11 00:12:51,655 - INFO -   Race 2025-12-27_83_11: 8 starts (results)
2026-01-11 00:12:52,365 - INFO -   Race 2025-12-27_83_12: 10 starts (results)
2026-01-11 00:12:52,365 - INFO - Processing track: Vincennes
2026-01-11 00:12:53,036 - INFO -   Race 2025-12-27_63_1: 7 starts (results)
2026-01-11 00:12:53,704 - INFO -   Race 2025-12-27_63_2: 11 starts (results)
2026-01-11 00:12:54,413 - INFO -   Race 2025-12-27_63_3: 10 starts (results)
2026-01-11 00:12:55,086 - INFO -   Race 2025-12-27_63_4: 15 starts (results)
2026-01-11 00:12:55,751 - INFO -   Race 2025-12-27_63_5: 11 starts (results)
2026-01-11 00:12:56,416 - INFO -   Race 2025-12-27_63_6: 16 starts (results)
2026-01-11 00:12:57,076 - INFO -   Race 2025-12-27_63_7: 16 starts (results)
2026-01-11 00:12:57,743 - INFO -   Race 2025-12-27_63_8: 8 starts (results)
2026-01-11 00:12:58,407 - INFO -   Race 2025-12-27_63_9: 12 starts (results)
2026-01-11 00:12:58,407 - INFO - Processing track: Sha Tin
2026-01-11 00:12:59,088 - INFO -   Race 2025-12-27_68_1: 14 starts (results)
2026-01-11 00:12:59,752 - INFO -   Race 2025-12-27_68_2: 14 starts (results)
2026-01-11 00:13:00,454 - INFO -   Race 2025-12-27_68_3: 9 starts (results)
2026-01-11 00:13:01,119 - INFO -   Race 2025-12-27_68_4: 14 starts (results)
2026-01-11 00:13:01,792 - INFO -   Race 2025-12-27_68_5: 14 starts (results)
2026-01-11 00:13:02,439 - INFO -   Race 2025-12-27_68_6: 14 starts (results)
2026-01-11 00:13:03,108 - INFO -   Race 2025-12-27_68_7: 14 starts (results)
2026-01-11 00:13:03,782 - INFO -   Race 2025-12-27_68_8: 14 starts (results)
2026-01-11 00:13:04,484 - INFO -   Race 2025-12-27_68_9: 14 starts (results)
2026-01-11 00:13:05,132 - INFO -   Race 2025-12-27_68_10: 14 starts (results)
2026-01-11 00:13:05,132 - INFO - Processing track: Gulfstream Park
2026-01-11 00:13:05,779 - INFO -   Race 2025-12-27_97_1: 15 starts (results)
2026-01-11 00:13:06,431 - INFO -   Race 2025-12-27_97_2: 10 starts (results)
2026-01-11 00:13:07,110 - INFO -   Race 2025-12-27_97_3: 7 starts (results)
2026-01-11 00:13:07,766 - INFO -   Race 2025-12-27_97_4: 9 starts (results)
2026-01-11 00:13:08,483 - INFO -   Race 2025-12-27_97_5: 10 starts (results)
2026-01-11 00:13:09,148 - INFO -   Race 2025-12-27_97_6: 7 starts (results)
2026-01-11 00:13:09,814 - INFO -   Race 2025-12-27_97_7: 12 starts (results)
2026-01-11 00:13:10,511 - INFO -   Race 2025-12-27_97_8: 8 starts (results)
2026-01-11 00:13:11,169 - INFO -   Race 2025-12-27_97_9: 10 starts (results)
2026-01-11 00:13:11,831 - INFO -   Race 2025-12-27_97_10: 8 starts (results)
2026-01-11 00:13:12,486 - INFO -   Race 2025-12-27_97_11: 10 starts (results)
2026-01-11 00:13:12,496 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:13:12,656 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:13:12,656 - INFO - Found V85 game: V85_2025-12-27_16_3 with 8 races
2026-01-11 00:13:12,656 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:13:12,656 - INFO - Fetching calendar for 2025-12-27
2026-01-11 00:13:12,920 - INFO - Found 5 tracks for 2025-12-27
2026-01-11 00:13:13,420 - INFO - Processing track: Gävle
2026-01-11 00:13:14,084 - INFO -   Race 2025-12-27_16_1: 15 starts (results)
2026-01-11 00:13:14,754 - INFO -   Race 2025-12-27_16_2: 8 starts (results)
2026-01-11 00:13:15,418 - INFO -   Race 2025-12-27_16_3: 12 starts (results)
2026-01-11 00:13:16,077 - INFO -   Race 2025-12-27_16_4: 11 starts (results)
2026-01-11 00:13:16,741 - INFO -   Race 2025-12-27_16_5: 15 starts (results)
2026-01-11 00:13:17,429 - INFO -   Race 2025-12-27_16_6: 12 starts (results)
2026-01-11 00:13:18,077 - INFO -   Race 2025-12-27_16_7: 15 starts (results)
2026-01-11 00:13:18,756 - INFO -   Race 2025-12-27_16_8: 15 starts (results)
2026-01-11 00:13:19,508 - INFO -   Race 2025-12-27_16_9: 12 starts (results)
2026-01-11 00:13:20,152 - INFO -   Race 2025-12-27_16_10: 12 starts (results)
2026-01-11 00:13:20,152 - INFO - Processing track: Orkla
2026-01-11 00:13:20,807 - INFO -   Race 2025-12-27_83_1: 8 starts (results)
2026-01-11 00:13:21,465 - INFO -   Race 2025-12-27_83_2: 9 starts (results)
2026-01-11 00:13:22,120 - INFO -   Race 2025-12-27_83_3: 11 starts (results)
2026-01-11 00:13:22,787 - INFO -   Race 2025-12-27_83_4: 12 starts (results)
2026-01-11 00:13:23,435 - INFO -   Race 2025-12-27_83_5: 10 starts (results)
2026-01-11 00:13:24,078 - INFO -   Race 2025-12-27_83_6: 12 starts (results)
2026-01-11 00:13:24,733 - INFO -   Race 2025-12-27_83_7: 12 starts (results)
2026-01-11 00:13:25,417 - INFO -   Race 2025-12-27_83_8: 11 starts (results)
2026-01-11 00:13:26,088 - INFO -   Race 2025-12-27_83_9: 8 starts (results)
2026-01-11 00:13:26,755 - INFO -   Race 2025-12-27_83_10: 7 starts (results)
2026-01-11 00:13:27,422 - INFO -   Race 2025-12-27_83_11: 8 starts (results)
2026-01-11 00:13:28,077 - INFO -   Race 2025-12-27_83_12: 10 starts (results)
2026-01-11 00:13:28,077 - INFO - Processing track: Vincennes
2026-01-11 00:13:28,730 - INFO -   Race 2025-12-27_63_1: 7 starts (results)
2026-01-11 00:13:29,413 - INFO -   Race 2025-12-27_63_2: 11 starts (results)
2026-01-11 00:13:30,157 - INFO -   Race 2025-12-27_63_3: 10 starts (results)
2026-01-11 00:13:30,824 - INFO -   Race 2025-12-27_63_4: 15 starts (results)
2026-01-11 00:13:31,486 - INFO -   Race 2025-12-27_63_5: 11 starts (results)
2026-01-11 00:13:32,163 - INFO -   Race 2025-12-27_63_6: 16 starts (results)
2026-01-11 00:13:32,819 - INFO -   Race 2025-12-27_63_7: 16 starts (results)
2026-01-11 00:13:33,465 - INFO -   Race 2025-12-27_63_8: 8 starts (results)
2026-01-11 00:13:34,129 - INFO -   Race 2025-12-27_63_9: 12 starts (results)
2026-01-11 00:13:34,129 - INFO - Processing track: Sha Tin
2026-01-11 00:13:34,809 - INFO -   Race 2025-12-27_68_1: 14 starts (results)
2026-01-11 00:13:35,480 - INFO -   Race 2025-12-27_68_2: 14 starts (results)
2026-01-11 00:13:36,128 - INFO -   Race 2025-12-27_68_3: 9 starts (results)
2026-01-11 00:13:36,787 - INFO -   Race 2025-12-27_68_4: 14 starts (results)
2026-01-11 00:13:37,455 - INFO -   Race 2025-12-27_68_5: 14 starts (results)
2026-01-11 00:13:38,103 - INFO -   Race 2025-12-27_68_6: 14 starts (results)
2026-01-11 00:13:38,751 - INFO -   Race 2025-12-27_68_7: 14 starts (results)
2026-01-11 00:13:39,409 - INFO -   Race 2025-12-27_68_8: 14 starts (results)
2026-01-11 00:13:40,087 - INFO -   Race 2025-12-27_68_9: 14 starts (results)
2026-01-11 00:13:40,738 - INFO -   Race 2025-12-27_68_10: 14 starts (results)
2026-01-11 00:13:40,738 - INFO - Processing track: Gulfstream Park
2026-01-11 00:13:41,385 - INFO -   Race 2025-12-27_97_1: 15 starts (results)
2026-01-11 00:13:42,056 - INFO -   Race 2025-12-27_97_2: 10 starts (results)
2026-01-11 00:13:42,747 - INFO -   Race 2025-12-27_97_3: 7 starts (results)
2026-01-11 00:13:43,416 - INFO -   Race 2025-12-27_97_4: 9 starts (results)
2026-01-11 00:13:44,065 - INFO -   Race 2025-12-27_97_5: 10 starts (results)
2026-01-11 00:13:44,710 - INFO -   Race 2025-12-27_97_6: 7 starts (results)
2026-01-11 00:13:45,364 - INFO -   Race 2025-12-27_97_7: 12 starts (results)
2026-01-11 00:13:46,007 - INFO -   Race 2025-12-27_97_8: 8 starts (results)
2026-01-11 00:13:46,668 - INFO -   Race 2025-12-27_97_9: 10 starts (results)
2026-01-11 00:13:47,321 - INFO -   Race 2025-12-27_97_10: 8 starts (results)
2026-01-11 00:13:47,968 - INFO -   Race 2025-12-27_97_11: 10 starts (results)
2026-01-11 00:13:47,976 - INFO - Fetching V85 races for 2025-12-26
2026-01-11 00:13:47,976 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:13:49,013 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:13:49,013 - INFO - Found V85 game: V85_2025-12-26_5_3 with 8 races
2026-01-11 00:13:49,014 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:13:49,014 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:13:49,161 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:13:49,661 - INFO - Processing track: Solvalla
2026-01-11 00:13:50,330 - INFO -   Race 2025-12-26_5_1: 7 starts (results)
2026-01-11 00:13:50,989 - INFO -   Race 2025-12-26_5_2: 11 starts (results)
2026-01-11 00:13:51,656 - INFO -   Race 2025-12-26_5_3: 12 starts (results)
2026-01-11 00:13:52,329 - INFO -   Race 2025-12-26_5_4: 10 starts (results)
2026-01-11 00:13:52,986 - INFO -   Race 2025-12-26_5_5: 8 starts (results)
2026-01-11 00:13:53,812 - INFO -   Race 2025-12-26_5_6: 11 starts (results)
2026-01-11 00:13:54,475 - INFO -   Race 2025-12-26_5_7: 12 starts (results)
2026-01-11 00:13:55,139 - INFO -   Race 2025-12-26_5_8: 12 starts (results)
2026-01-11 00:13:55,809 - INFO -   Race 2025-12-26_5_9: 11 starts (results)
2026-01-11 00:13:56,474 - INFO -   Race 2025-12-26_5_10: 15 starts (results)
2026-01-11 00:13:56,474 - INFO - Processing track: Bjerke
2026-01-11 00:13:57,166 - INFO -   Race 2025-12-26_78_1: 9 starts (results)
2026-01-11 00:13:57,856 - INFO -   Race 2025-12-26_78_2: 11 starts (results)
2026-01-11 00:13:58,566 - INFO -   Race 2025-12-26_78_3: 13 starts (results)
2026-01-11 00:13:59,272 - INFO -   Race 2025-12-26_78_4: 9 starts (results)
2026-01-11 00:13:59,957 - INFO -   Race 2025-12-26_78_5: 12 starts (results)
2026-01-11 00:14:00,648 - INFO -   Race 2025-12-26_78_6: 11 starts (results)
2026-01-11 00:14:01,322 - INFO -   Race 2025-12-26_78_7: 7 starts (results)
2026-01-11 00:14:01,322 - INFO - Processing track: Bordeaux
2026-01-11 00:14:01,997 - INFO -   Race 2025-12-26_62_1: 13 starts (results)
2026-01-11 00:14:02,719 - INFO -   Race 2025-12-26_62_2: 14 starts (results)
2026-01-11 00:14:03,415 - INFO -   Race 2025-12-26_62_3: 10 starts (results)
2026-01-11 00:14:04,112 - INFO -   Race 2025-12-26_62_4: 12 starts (results)
2026-01-11 00:14:04,820 - INFO -   Race 2025-12-26_62_5: 15 starts (results)
2026-01-11 00:14:05,510 - INFO -   Race 2025-12-26_62_6: 9 starts (results)
2026-01-11 00:14:06,197 - INFO -   Race 2025-12-26_62_7: 12 starts (results)
2026-01-11 00:14:06,885 - INFO -   Race 2025-12-26_62_8: 15 starts (results)
2026-01-11 00:14:06,885 - INFO - Processing track: Vincennes
2026-01-11 00:14:07,912 - INFO -   Race 2025-12-26_63_1: 9 starts (results)
2026-01-11 00:14:08,603 - INFO -   Race 2025-12-26_63_2: 10 starts (results)
2026-01-11 00:14:09,299 - INFO -   Race 2025-12-26_63_3: 12 starts (results)
2026-01-11 00:14:09,991 - INFO -   Race 2025-12-26_63_4: 12 starts (results)
2026-01-11 00:14:10,677 - INFO -   Race 2025-12-26_63_5: 14 starts (results)
2026-01-11 00:14:11,355 - INFO -   Race 2025-12-26_63_6: 9 starts (results)
2026-01-11 00:14:12,032 - INFO -   Race 2025-12-26_63_7: 8 starts (results)
2026-01-11 00:14:12,729 - INFO -   Race 2025-12-26_63_8: 15 starts (results)
2026-01-11 00:14:12,729 - INFO - Processing track: Gulfstream Park
2026-01-11 00:14:13,414 - INFO -   Race 2025-12-26_97_1: 11 starts (results)
2026-01-11 00:14:14,096 - INFO -   Race 2025-12-26_97_2: 9 starts (results)
2026-01-11 00:14:14,776 - INFO -   Race 2025-12-26_97_3: 6 starts (results)
2026-01-11 00:14:15,479 - INFO -   Race 2025-12-26_97_4: 8 starts (results)
2026-01-11 00:14:16,147 - INFO -   Race 2025-12-26_97_5: 7 starts (results)
2026-01-11 00:14:16,845 - INFO -   Race 2025-12-26_97_6: 6 starts (results)
2026-01-11 00:14:17,623 - INFO -   Race 2025-12-26_97_7: 8 starts (results)
2026-01-11 00:14:18,301 - INFO -   Race 2025-12-26_97_8: 9 starts (results)
2026-01-11 00:14:19,029 - INFO -   Race 2025-12-26_97_9: 9 starts (results)
2026-01-11 00:14:19,719 - INFO -   Race 2025-12-26_97_10: 9 starts (results)
2026-01-11 00:14:19,723 - INFO - V85 Game: V85_2025-12-26_5_3
2026-01-11 00:14:19,723 - INFO - Loaded 91 horses from 8 V85 races
2026-01-11 00:14:19,723 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:14:19,723 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:14:19,725 - INFO - Added temporal features
2026-01-11 00:14:19,725 - INFO - Added post position features
2026-01-11 00:14:19,726 - INFO - Calculated driver/trainer rates
2026-01-11 00:14:19,727 - INFO - Added speed features
2026-01-11 00:14:19,727 - INFO - Added track importance features
2026-01-11 00:14:19,728 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:14:19,886 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:14:21,351 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:14:21,351 - INFO - Found V85 game: V85_2025-12-26_5_3 with 8 races
2026-01-11 00:14:21,351 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:14:21,351 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:14:21,523 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:14:22,023 - INFO - Processing track: Solvalla
2026-01-11 00:14:22,683 - INFO -   Race 2025-12-26_5_1: 7 starts (results)
2026-01-11 00:14:23,336 - INFO -   Race 2025-12-26_5_2: 11 starts (results)
2026-01-11 00:14:24,049 - INFO -   Race 2025-12-26_5_3: 12 starts (results)
2026-01-11 00:14:24,700 - INFO -   Race 2025-12-26_5_4: 10 starts (results)
2026-01-11 00:14:25,352 - INFO -   Race 2025-12-26_5_5: 8 starts (results)
2026-01-11 00:14:26,010 - INFO -   Race 2025-12-26_5_6: 11 starts (results)
2026-01-11 00:14:26,686 - INFO -   Race 2025-12-26_5_7: 12 starts (results)
2026-01-11 00:14:27,347 - INFO -   Race 2025-12-26_5_8: 12 starts (results)
2026-01-11 00:14:28,039 - INFO -   Race 2025-12-26_5_9: 11 starts (results)
2026-01-11 00:14:28,691 - INFO -   Race 2025-12-26_5_10: 15 starts (results)
2026-01-11 00:14:28,691 - INFO - Processing track: Bjerke
2026-01-11 00:14:29,370 - INFO -   Race 2025-12-26_78_1: 9 starts (results)
2026-01-11 00:14:30,037 - INFO -   Race 2025-12-26_78_2: 11 starts (results)
2026-01-11 00:14:30,705 - INFO -   Race 2025-12-26_78_3: 13 starts (results)
2026-01-11 00:14:31,362 - INFO -   Race 2025-12-26_78_4: 9 starts (results)
2026-01-11 00:14:32,008 - INFO -   Race 2025-12-26_78_5: 12 starts (results)
2026-01-11 00:14:32,678 - INFO -   Race 2025-12-26_78_6: 11 starts (results)
2026-01-11 00:14:33,335 - INFO -   Race 2025-12-26_78_7: 7 starts (results)
2026-01-11 00:14:33,335 - INFO - Processing track: Bordeaux
2026-01-11 00:14:34,027 - INFO -   Race 2025-12-26_62_1: 13 starts (results)
2026-01-11 00:14:34,673 - INFO -   Race 2025-12-26_62_2: 14 starts (results)
2026-01-11 00:14:35,363 - INFO -   Race 2025-12-26_62_3: 10 starts (results)
2026-01-11 00:14:36,027 - INFO -   Race 2025-12-26_62_4: 12 starts (results)
2026-01-11 00:14:36,720 - INFO -   Race 2025-12-26_62_5: 15 starts (results)
2026-01-11 00:14:37,380 - INFO -   Race 2025-12-26_62_6: 9 starts (results)
2026-01-11 00:14:38,052 - INFO -   Race 2025-12-26_62_7: 12 starts (results)
2026-01-11 00:14:38,718 - INFO -   Race 2025-12-26_62_8: 15 starts (results)
2026-01-11 00:14:38,718 - INFO - Processing track: Vincennes
2026-01-11 00:14:39,373 - INFO -   Race 2025-12-26_63_1: 9 starts (results)
2026-01-11 00:14:40,027 - INFO -   Race 2025-12-26_63_2: 10 starts (results)
2026-01-11 00:14:40,689 - INFO -   Race 2025-12-26_63_3: 12 starts (results)
2026-01-11 00:14:41,338 - INFO -   Race 2025-12-26_63_4: 12 starts (results)
2026-01-11 00:14:41,991 - INFO -   Race 2025-12-26_63_5: 14 starts (results)
2026-01-11 00:14:42,655 - INFO -   Race 2025-12-26_63_6: 9 starts (results)
2026-01-11 00:14:43,319 - INFO -   Race 2025-12-26_63_7: 8 starts (results)
2026-01-11 00:14:43,968 - INFO -   Race 2025-12-26_63_8: 15 starts (results)
2026-01-11 00:14:43,968 - INFO - Processing track: Gulfstream Park
2026-01-11 00:14:44,627 - INFO -   Race 2025-12-26_97_1: 11 starts (results)
2026-01-11 00:14:45,274 - INFO -   Race 2025-12-26_97_2: 9 starts (results)
2026-01-11 00:14:45,926 - INFO -   Race 2025-12-26_97_3: 6 starts (results)
2026-01-11 00:14:46,578 - INFO -   Race 2025-12-26_97_4: 8 starts (results)
2026-01-11 00:14:47,244 - INFO -   Race 2025-12-26_97_5: 7 starts (results)
2026-01-11 00:14:47,894 - INFO -   Race 2025-12-26_97_6: 6 starts (results)
2026-01-11 00:14:48,549 - INFO -   Race 2025-12-26_97_7: 8 starts (results)
2026-01-11 00:14:49,209 - INFO -   Race 2025-12-26_97_8: 9 starts (results)
2026-01-11 00:14:49,859 - INFO -   Race 2025-12-26_97_9: 9 starts (results)
2026-01-11 00:14:50,515 - INFO -   Race 2025-12-26_97_10: 9 starts (results)
2026-01-11 00:14:50,526 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:14:50,682 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:14:50,682 - INFO - Found V85 game: V85_2025-12-26_5_3 with 8 races
2026-01-11 00:14:50,682 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:14:50,682 - INFO - Fetching calendar for 2025-12-26
2026-01-11 00:14:50,837 - INFO - Found 5 tracks for 2025-12-26
2026-01-11 00:14:51,337 - INFO - Processing track: Solvalla
2026-01-11 00:14:51,992 - INFO -   Race 2025-12-26_5_1: 7 starts (results)
2026-01-11 00:14:52,665 - INFO -   Race 2025-12-26_5_2: 11 starts (results)
2026-01-11 00:14:53,333 - INFO -   Race 2025-12-26_5_3: 12 starts (results)
2026-01-11 00:14:53,984 - INFO -   Race 2025-12-26_5_4: 10 starts (results)
2026-01-11 00:14:54,640 - INFO -   Race 2025-12-26_5_5: 8 starts (results)
2026-01-11 00:14:55,298 - INFO -   Race 2025-12-26_5_6: 11 starts (results)
2026-01-11 00:14:55,970 - INFO -   Race 2025-12-26_5_7: 12 starts (results)
2026-01-11 00:14:56,646 - INFO -   Race 2025-12-26_5_8: 12 starts (results)
2026-01-11 00:14:57,299 - INFO -   Race 2025-12-26_5_9: 11 starts (results)
2026-01-11 00:14:57,950 - INFO -   Race 2025-12-26_5_10: 15 starts (results)
2026-01-11 00:14:57,950 - INFO - Processing track: Bjerke
2026-01-11 00:14:58,610 - INFO -   Race 2025-12-26_78_1: 9 starts (results)
2026-01-11 00:14:59,278 - INFO -   Race 2025-12-26_78_2: 11 starts (results)
2026-01-11 00:14:59,962 - INFO -   Race 2025-12-26_78_3: 13 starts (results)
2026-01-11 00:15:00,656 - INFO -   Race 2025-12-26_78_4: 9 starts (results)
2026-01-11 00:15:01,319 - INFO -   Race 2025-12-26_78_5: 12 starts (results)
2026-01-11 00:15:01,962 - INFO -   Race 2025-12-26_78_6: 11 starts (results)
2026-01-11 00:15:02,605 - INFO -   Race 2025-12-26_78_7: 7 starts (results)
2026-01-11 00:15:02,606 - INFO - Processing track: Bordeaux
2026-01-11 00:15:03,264 - INFO -   Race 2025-12-26_62_1: 13 starts (results)
2026-01-11 00:15:03,929 - INFO -   Race 2025-12-26_62_2: 14 starts (results)
2026-01-11 00:15:04,600 - INFO -   Race 2025-12-26_62_3: 10 starts (results)
2026-01-11 00:15:05,260 - INFO -   Race 2025-12-26_62_4: 12 starts (results)
2026-01-11 00:15:05,927 - INFO -   Race 2025-12-26_62_5: 15 starts (results)
2026-01-11 00:15:06,578 - INFO -   Race 2025-12-26_62_6: 9 starts (results)
2026-01-11 00:15:07,242 - INFO -   Race 2025-12-26_62_7: 12 starts (results)
2026-01-11 00:15:07,898 - INFO -   Race 2025-12-26_62_8: 15 starts (results)
2026-01-11 00:15:07,898 - INFO - Processing track: Vincennes
2026-01-11 00:15:08,562 - INFO -   Race 2025-12-26_63_1: 9 starts (results)
2026-01-11 00:15:09,204 - INFO -   Race 2025-12-26_63_2: 10 starts (results)
2026-01-11 00:15:09,864 - INFO -   Race 2025-12-26_63_3: 12 starts (results)
2026-01-11 00:15:10,524 - INFO -   Race 2025-12-26_63_4: 12 starts (results)
2026-01-11 00:15:11,213 - INFO -   Race 2025-12-26_63_5: 14 starts (results)
2026-01-11 00:15:11,885 - INFO -   Race 2025-12-26_63_6: 9 starts (results)
2026-01-11 00:15:12,540 - INFO -   Race 2025-12-26_63_7: 8 starts (results)
2026-01-11 00:15:13,206 - INFO -   Race 2025-12-26_63_8: 15 starts (results)
2026-01-11 00:15:13,206 - INFO - Processing track: Gulfstream Park
2026-01-11 00:15:13,857 - INFO -   Race 2025-12-26_97_1: 11 starts (results)
2026-01-11 00:15:14,501 - INFO -   Race 2025-12-26_97_2: 9 starts (results)
2026-01-11 00:15:15,165 - INFO -   Race 2025-12-26_97_3: 6 starts (results)
2026-01-11 00:15:15,818 - INFO -   Race 2025-12-26_97_4: 8 starts (results)
2026-01-11 00:15:16,460 - INFO -   Race 2025-12-26_97_5: 7 starts (results)
2026-01-11 00:15:17,112 - INFO -   Race 2025-12-26_97_6: 6 starts (results)
2026-01-11 00:15:17,761 - INFO -   Race 2025-12-26_97_7: 8 starts (results)
2026-01-11 00:15:18,420 - INFO -   Race 2025-12-26_97_8: 9 starts (results)
2026-01-11 00:15:19,071 - INFO -   Race 2025-12-26_97_9: 9 starts (results)
2026-01-11 00:15:19,730 - INFO -   Race 2025-12-26_97_10: 9 starts (results)
2026-01-11 00:15:19,739 - INFO - Fetching V85 races for 2025-12-25
2026-01-11 00:15:19,739 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:20,525 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:15:20,525 - INFO - Found V85 game: V85_2025-12-25_27_3 with 8 races
2026-01-11 00:15:20,525 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:15:20,525 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:20,671 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:15:21,171 - INFO - Processing track: Umåker
2026-01-11 00:15:21,870 - INFO -   Race 2025-12-25_27_1: 8 starts (results)
2026-01-11 00:15:22,587 - INFO -   Race 2025-12-25_27_2: 11 starts (results)
2026-01-11 00:15:23,264 - INFO -   Race 2025-12-25_27_3: 12 starts (results)
2026-01-11 00:15:23,949 - INFO -   Race 2025-12-25_27_4: 15 starts (results)
2026-01-11 00:15:24,635 - INFO -   Race 2025-12-25_27_5: 12 starts (results)
2026-01-11 00:15:25,307 - INFO -   Race 2025-12-25_27_6: 10 starts (results)
2026-01-11 00:15:25,970 - INFO -   Race 2025-12-25_27_7: 12 starts (results)
2026-01-11 00:15:26,638 - INFO -   Race 2025-12-25_27_8: 12 starts (results)
2026-01-11 00:15:27,310 - INFO -   Race 2025-12-25_27_9: 12 starts (results)
2026-01-11 00:15:27,981 - INFO -   Race 2025-12-25_27_10: 15 starts (results)
2026-01-11 00:15:27,981 - INFO - Processing track: Forus
2026-01-11 00:15:28,679 - INFO -   Race 2025-12-25_81_1: 5 starts (results)
2026-01-11 00:15:29,400 - INFO -   Race 2025-12-25_81_2: 14 starts (results)
2026-01-11 00:15:30,113 - INFO -   Race 2025-12-25_81_3: 9 starts (results)
2026-01-11 00:15:30,816 - INFO -   Race 2025-12-25_81_4: 10 starts (results)
2026-01-11 00:15:31,500 - INFO -   Race 2025-12-25_81_5: 12 starts (results)
2026-01-11 00:15:32,184 - INFO -   Race 2025-12-25_81_6: 14 starts (results)
2026-01-11 00:15:32,865 - INFO -   Race 2025-12-25_81_7: 12 starts (results)
2026-01-11 00:15:33,544 - INFO -   Race 2025-12-25_81_8: 9 starts (results)
2026-01-11 00:15:34,225 - INFO -   Race 2025-12-25_81_9: 8 starts (results)
2026-01-11 00:15:34,225 - INFO - Processing track: Vincennes
2026-01-11 00:15:34,889 - INFO -   Race 2025-12-25_63_1: 7 starts (results)
2026-01-11 00:15:35,599 - INFO -   Race 2025-12-25_63_2: 11 starts (results)
2026-01-11 00:15:36,323 - INFO -   Race 2025-12-25_63_3: 9 starts (results)
2026-01-11 00:15:37,006 - INFO -   Race 2025-12-25_63_4: 13 starts (results)
2026-01-11 00:15:37,708 - INFO -   Race 2025-12-25_63_5: 16 starts (results)
2026-01-11 00:15:38,383 - INFO -   Race 2025-12-25_63_6: 12 starts (results)
2026-01-11 00:15:39,072 - INFO -   Race 2025-12-25_63_7: 11 starts (results)
2026-01-11 00:15:39,773 - INFO -   Race 2025-12-25_63_8: 16 starts (results)
2026-01-11 00:15:39,776 - INFO - V85 Game: V85_2025-12-25_27_3
2026-01-11 00:15:39,776 - INFO - Loaded 100 horses from 8 V85 races
2026-01-11 00:15:39,776 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:15:39,776 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:15:39,778 - INFO - Added temporal features
2026-01-11 00:15:39,779 - INFO - Added post position features
2026-01-11 00:15:39,780 - INFO - Calculated driver/trainer rates
2026-01-11 00:15:39,780 - INFO - Added speed features
2026-01-11 00:15:39,780 - INFO - Added track importance features
2026-01-11 00:15:39,782 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:15:39,938 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:40,564 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:15:40,564 - INFO - Found V85 game: V85_2025-12-25_27_3 with 8 races
2026-01-11 00:15:40,564 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:15:40,564 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:40,705 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:15:41,205 - INFO - Processing track: Umåker
2026-01-11 00:15:41,872 - INFO -   Race 2025-12-25_27_1: 8 starts (results)
2026-01-11 00:15:42,528 - INFO -   Race 2025-12-25_27_2: 11 starts (results)
2026-01-11 00:15:43,182 - INFO -   Race 2025-12-25_27_3: 12 starts (results)
2026-01-11 00:15:43,834 - INFO -   Race 2025-12-25_27_4: 15 starts (results)
2026-01-11 00:15:44,481 - INFO -   Race 2025-12-25_27_5: 12 starts (results)
2026-01-11 00:15:45,139 - INFO -   Race 2025-12-25_27_6: 10 starts (results)
2026-01-11 00:15:45,791 - INFO -   Race 2025-12-25_27_7: 12 starts (results)
2026-01-11 00:15:46,549 - INFO -   Race 2025-12-25_27_8: 12 starts (results)
2026-01-11 00:15:47,196 - INFO -   Race 2025-12-25_27_9: 12 starts (results)
2026-01-11 00:15:47,846 - INFO -   Race 2025-12-25_27_10: 15 starts (results)
2026-01-11 00:15:47,846 - INFO - Processing track: Forus
2026-01-11 00:15:48,524 - INFO -   Race 2025-12-25_81_1: 5 starts (results)
2026-01-11 00:15:49,174 - INFO -   Race 2025-12-25_81_2: 14 starts (results)
2026-01-11 00:15:49,824 - INFO -   Race 2025-12-25_81_3: 9 starts (results)
2026-01-11 00:15:50,481 - INFO -   Race 2025-12-25_81_4: 10 starts (results)
2026-01-11 00:15:51,137 - INFO -   Race 2025-12-25_81_5: 12 starts (results)
2026-01-11 00:15:51,783 - INFO -   Race 2025-12-25_81_6: 14 starts (results)
2026-01-11 00:15:52,446 - INFO -   Race 2025-12-25_81_7: 12 starts (results)
2026-01-11 00:15:53,105 - INFO -   Race 2025-12-25_81_8: 9 starts (results)
2026-01-11 00:15:53,778 - INFO -   Race 2025-12-25_81_9: 8 starts (results)
2026-01-11 00:15:53,778 - INFO - Processing track: Vincennes
2026-01-11 00:15:54,425 - INFO -   Race 2025-12-25_63_1: 7 starts (results)
2026-01-11 00:15:55,259 - INFO -   Race 2025-12-25_63_2: 11 starts (results)
2026-01-11 00:15:55,914 - INFO -   Race 2025-12-25_63_3: 9 starts (results)
2026-01-11 00:15:56,566 - INFO -   Race 2025-12-25_63_4: 13 starts (results)
2026-01-11 00:15:57,235 - INFO -   Race 2025-12-25_63_5: 16 starts (results)
2026-01-11 00:15:57,889 - INFO -   Race 2025-12-25_63_6: 12 starts (results)
2026-01-11 00:15:58,563 - INFO -   Race 2025-12-25_63_7: 11 starts (results)
2026-01-11 00:15:59,255 - INFO -   Race 2025-12-25_63_8: 16 starts (results)
2026-01-11 00:15:59,263 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:59,501 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:15:59,501 - INFO - Found V85 game: V85_2025-12-25_27_3 with 8 races
2026-01-11 00:15:59,501 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:15:59,501 - INFO - Fetching calendar for 2025-12-25
2026-01-11 00:15:59,655 - INFO - Found 3 tracks for 2025-12-25
2026-01-11 00:16:00,155 - INFO - Processing track: Umåker
2026-01-11 00:16:00,811 - INFO -   Race 2025-12-25_27_1: 8 starts (results)
2026-01-11 00:16:01,483 - INFO -   Race 2025-12-25_27_2: 11 starts (results)
2026-01-11 00:16:02,131 - INFO -   Race 2025-12-25_27_3: 12 starts (results)
2026-01-11 00:16:02,797 - INFO -   Race 2025-12-25_27_4: 15 starts (results)
2026-01-11 00:16:03,459 - INFO -   Race 2025-12-25_27_5: 12 starts (results)
2026-01-11 00:16:04,119 - INFO -   Race 2025-12-25_27_6: 10 starts (results)
2026-01-11 00:16:04,763 - INFO -   Race 2025-12-25_27_7: 12 starts (results)
2026-01-11 00:16:05,448 - INFO -   Race 2025-12-25_27_8: 12 starts (results)
2026-01-11 00:16:06,116 - INFO -   Race 2025-12-25_27_9: 12 starts (results)
2026-01-11 00:16:06,791 - INFO -   Race 2025-12-25_27_10: 15 starts (results)
2026-01-11 00:16:06,791 - INFO - Processing track: Forus
2026-01-11 00:16:07,439 - INFO -   Race 2025-12-25_81_1: 5 starts (results)
2026-01-11 00:16:08,094 - INFO -   Race 2025-12-25_81_2: 14 starts (results)
2026-01-11 00:16:08,741 - INFO -   Race 2025-12-25_81_3: 9 starts (results)
2026-01-11 00:16:09,388 - INFO -   Race 2025-12-25_81_4: 10 starts (results)
2026-01-11 00:16:10,060 - INFO -   Race 2025-12-25_81_5: 12 starts (results)
2026-01-11 00:16:10,717 - INFO -   Race 2025-12-25_81_6: 14 starts (results)
2026-01-11 00:16:11,367 - INFO -   Race 2025-12-25_81_7: 12 starts (results)
2026-01-11 00:16:12,012 - INFO -   Race 2025-12-25_81_8: 9 starts (results)
2026-01-11 00:16:12,658 - INFO -   Race 2025-12-25_81_9: 8 starts (results)
2026-01-11 00:16:12,658 - INFO - Processing track: Vincennes
2026-01-11 00:16:13,320 - INFO -   Race 2025-12-25_63_1: 7 starts (results)
2026-01-11 00:16:13,983 - INFO -   Race 2025-12-25_63_2: 11 starts (results)
2026-01-11 00:16:14,661 - INFO -   Race 2025-12-25_63_3: 9 starts (results)
2026-01-11 00:16:15,305 - INFO -   Race 2025-12-25_63_4: 13 starts (results)
2026-01-11 00:16:15,967 - INFO -   Race 2025-12-25_63_5: 16 starts (results)
2026-01-11 00:16:16,613 - INFO -   Race 2025-12-25_63_6: 12 starts (results)
2026-01-11 00:16:17,286 - INFO -   Race 2025-12-25_63_7: 11 starts (results)
2026-01-11 00:16:17,934 - INFO -   Race 2025-12-25_63_8: 16 starts (results)
2026-01-11 00:16:17,941 - INFO - Fetching V85 races for 2025-12-23
2026-01-11 00:16:17,941 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:16:18,882 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:16:18,882 - INFO - Found V85 game: V85_2025-12-23_32_3 with 8 races
2026-01-11 00:16:18,882 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:16:18,882 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:16:19,031 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:16:19,531 - INFO - Processing track: Örebro
2026-01-11 00:16:20,416 - INFO -   Race 2025-12-23_32_1: 7 starts (results)
2026-01-11 00:16:21,120 - INFO -   Race 2025-12-23_32_2: 15 starts (results)
2026-01-11 00:16:21,781 - INFO -   Race 2025-12-23_32_3: 12 starts (results)
2026-01-11 00:16:22,434 - INFO -   Race 2025-12-23_32_4: 12 starts (results)
2026-01-11 00:16:23,088 - INFO -   Race 2025-12-23_32_5: 12 starts (results)
2026-01-11 00:16:23,761 - INFO -   Race 2025-12-23_32_6: 12 starts (results)
2026-01-11 00:16:24,418 - INFO -   Race 2025-12-23_32_7: 12 starts (results)
2026-01-11 00:16:25,085 - INFO -   Race 2025-12-23_32_8: 12 starts (results)
2026-01-11 00:16:25,779 - INFO -   Race 2025-12-23_32_9: 12 starts (results)
2026-01-11 00:16:26,459 - INFO -   Race 2025-12-23_32_10: 15 starts (results)
2026-01-11 00:16:26,459 - INFO - Processing track: Jarlsberg
2026-01-11 00:16:27,140 - INFO -   Race 2025-12-23_82_1: 9 starts (results)
2026-01-11 00:16:27,820 - INFO -   Race 2025-12-23_82_2: 8 starts (results)
2026-01-11 00:16:28,513 - INFO -   Race 2025-12-23_82_3: 12 starts (results)
2026-01-11 00:16:29,197 - INFO -   Race 2025-12-23_82_4: 8 starts (results)
2026-01-11 00:16:29,899 - INFO -   Race 2025-12-23_82_5: 11 starts (results)
2026-01-11 00:16:30,591 - INFO -   Race 2025-12-23_82_6: 10 starts (results)
2026-01-11 00:16:31,287 - INFO -   Race 2025-12-23_82_7: 9 starts (results)
2026-01-11 00:16:31,287 - INFO - Processing track: Åby
2026-01-11 00:16:31,967 - INFO -   Race 2025-12-23_6_1: 9 starts (results)
2026-01-11 00:16:32,634 - INFO -   Race 2025-12-23_6_2: 12 starts (results)
2026-01-11 00:16:33,297 - INFO -   Race 2025-12-23_6_3: 12 starts (results)
2026-01-11 00:16:33,959 - INFO -   Race 2025-12-23_6_4: 10 starts (results)
2026-01-11 00:16:34,626 - INFO -   Race 2025-12-23_6_5: 11 starts (results)
2026-01-11 00:16:35,301 - INFO -   Race 2025-12-23_6_6: 12 starts (results)
2026-01-11 00:16:35,985 - INFO -   Race 2025-12-23_6_7: 15 starts (results)
2026-01-11 00:16:35,985 - INFO - Processing track: Happy Valley
2026-01-11 00:16:36,700 - INFO -   Race 2025-12-23_68_1: 12 starts (results)
2026-01-11 00:16:37,400 - INFO -   Race 2025-12-23_68_2: 12 starts (results)
2026-01-11 00:16:38,086 - INFO -   Race 2025-12-23_68_3: 12 starts (results)
2026-01-11 00:16:38,775 - INFO -   Race 2025-12-23_68_4: 12 starts (results)
2026-01-11 00:16:39,476 - INFO -   Race 2025-12-23_68_5: 12 starts (results)
2026-01-11 00:16:40,154 - INFO -   Race 2025-12-23_68_6: 12 starts (results)
2026-01-11 00:16:40,833 - INFO -   Race 2025-12-23_68_7: 12 starts (results)
2026-01-11 00:16:41,504 - INFO -   Race 2025-12-23_68_8: 12 starts (results)
2026-01-11 00:16:42,190 - INFO -   Race 2025-12-23_68_9: 12 starts (results)
2026-01-11 00:16:42,194 - INFO - V85 Game: V85_2025-12-23_32_3
2026-01-11 00:16:42,194 - INFO - Loaded 99 horses from 8 V85 races
2026-01-11 00:16:42,194 - INFO - Track race numbers: [np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8), np.int64(9), np.int64(10)]
2026-01-11 00:16:42,194 - INFO - V85 race numbers: [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7), np.int64(8)]
2026-01-11 00:16:42,196 - INFO - Added temporal features
2026-01-11 00:16:42,196 - INFO - Added post position features
2026-01-11 00:16:42,197 - INFO - Calculated driver/trainer rates
2026-01-11 00:16:42,198 - INFO - Added speed features
2026-01-11 00:16:42,198 - INFO - Added track importance features
2026-01-11 00:16:42,200 - INFO - Encoded categorical variables
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
/home/per/Work/trav/predict_v85.py:171: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[feat] = 0
2026-01-11 00:16:42,360 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:16:42,988 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:16:42,988 - INFO - Found V85 game: V85_2025-12-23_32_3 with 8 races
2026-01-11 00:16:42,988 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:16:42,988 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:16:43,141 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:16:43,641 - INFO - Processing track: Örebro
2026-01-11 00:16:44,301 - INFO -   Race 2025-12-23_32_1: 7 starts (results)
2026-01-11 00:16:44,983 - INFO -   Race 2025-12-23_32_2: 15 starts (results)
2026-01-11 00:16:45,641 - INFO -   Race 2025-12-23_32_3: 12 starts (results)
2026-01-11 00:16:46,299 - INFO -   Race 2025-12-23_32_4: 12 starts (results)
2026-01-11 00:16:46,968 - INFO -   Race 2025-12-23_32_5: 12 starts (results)
2026-01-11 00:16:47,639 - INFO -   Race 2025-12-23_32_6: 12 starts (results)
2026-01-11 00:16:48,302 - INFO -   Race 2025-12-23_32_7: 12 starts (results)
2026-01-11 00:16:48,972 - INFO -   Race 2025-12-23_32_8: 12 starts (results)
2026-01-11 00:16:49,636 - INFO -   Race 2025-12-23_32_9: 12 starts (results)
2026-01-11 00:16:50,303 - INFO -   Race 2025-12-23_32_10: 15 starts (results)
2026-01-11 00:16:50,303 - INFO - Processing track: Jarlsberg
2026-01-11 00:16:50,967 - INFO -   Race 2025-12-23_82_1: 9 starts (results)
2026-01-11 00:16:51,627 - INFO -   Race 2025-12-23_82_2: 8 starts (results)
2026-01-11 00:16:52,300 - INFO -   Race 2025-12-23_82_3: 12 starts (results)
2026-01-11 00:16:52,958 - INFO -   Race 2025-12-23_82_4: 8 starts (results)
2026-01-11 00:16:53,865 - INFO -   Race 2025-12-23_82_5: 11 starts (results)
2026-01-11 00:16:54,519 - INFO -   Race 2025-12-23_82_6: 10 starts (results)
2026-01-11 00:16:55,171 - INFO -   Race 2025-12-23_82_7: 9 starts (results)
2026-01-11 00:16:55,171 - INFO - Processing track: Åby
2026-01-11 00:16:55,853 - INFO -   Race 2025-12-23_6_1: 9 starts (results)
2026-01-11 00:16:56,539 - INFO -   Race 2025-12-23_6_2: 12 starts (results)
2026-01-11 00:16:57,209 - INFO -   Race 2025-12-23_6_3: 12 starts (results)
2026-01-11 00:16:57,860 - INFO -   Race 2025-12-23_6_4: 10 starts (results)
2026-01-11 00:16:58,545 - INFO -   Race 2025-12-23_6_5: 11 starts (results)
2026-01-11 00:16:59,215 - INFO -   Race 2025-12-23_6_6: 12 starts (results)
2026-01-11 00:16:59,928 - INFO -   Race 2025-12-23_6_7: 15 starts (results)
2026-01-11 00:16:59,928 - INFO - Processing track: Happy Valley
2026-01-11 00:17:00,588 - INFO -   Race 2025-12-23_68_1: 12 starts (results)
2026-01-11 00:17:01,252 - INFO -   Race 2025-12-23_68_2: 12 starts (results)
2026-01-11 00:17:01,915 - INFO -   Race 2025-12-23_68_3: 12 starts (results)
2026-01-11 00:17:02,587 - INFO -   Race 2025-12-23_68_4: 12 starts (results)
2026-01-11 00:17:03,244 - INFO -   Race 2025-12-23_68_5: 12 starts (results)
2026-01-11 00:17:03,901 - INFO -   Race 2025-12-23_68_6: 12 starts (results)
2026-01-11 00:17:04,547 - INFO -   Race 2025-12-23_68_7: 12 starts (results)
2026-01-11 00:17:05,195 - INFO -   Race 2025-12-23_68_8: 12 starts (results)
2026-01-11 00:17:05,868 - INFO -   Race 2025-12-23_68_9: 12 starts (results)
2026-01-11 00:17:05,877 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:17:06,023 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:17:06,023 - INFO - Found V85 game: V85_2025-12-23_32_3 with 8 races
2026-01-11 00:17:06,023 - INFO - V85 races: track races ['3', '4', '5', '6', '7', '8', '9', '10'] → V85 races 1-8
2026-01-11 00:17:06,023 - INFO - Fetching calendar for 2025-12-23
2026-01-11 00:17:06,196 - INFO - Found 4 tracks for 2025-12-23
2026-01-11 00:17:06,696 - INFO - Processing track: Örebro
2026-01-11 00:17:07,342 - INFO -   Race 2025-12-23_32_1: 7 starts (results)
2026-01-11 00:17:08,023 - INFO -   Race 2025-12-23_32_2: 15 starts (results)
2026-01-11 00:17:08,674 - INFO -   Race 2025-12-23_32_3: 12 starts (results)
2026-01-11 00:17:09,325 - INFO -   Race 2025-12-23_32_4: 12 starts (results)
2026-01-11 00:17:09,993 - INFO -   Race 2025-12-23_32_5: 12 starts (results)
2026-01-11 00:17:10,661 - INFO -   Race 2025-12-23_32_6: 12 starts (results)
2026-01-11 00:17:11,324 - INFO -   Race 2025-12-23_32_7: 12 starts (results)
2026-01-11 00:17:11,983 - INFO -   Race 2025-12-23_32_8: 12 starts (results)
2026-01-11 00:17:12,632 - INFO -   Race 2025-12-23_32_9: 12 starts (results)
2026-01-11 00:17:13,289 - INFO -   Race 2025-12-23_32_10: 15 starts (results)
2026-01-11 00:17:13,290 - INFO - Processing track: Jarlsberg
2026-01-11 00:17:13,950 - INFO -   Race 2025-12-23_82_1: 9 starts (results)
2026-01-11 00:17:14,613 - INFO -   Race 2025-12-23_82_2: 8 starts (results)
2026-01-11 00:17:15,267 - INFO -   Race 2025-12-23_82_3: 12 starts (results)
2026-01-11 00:17:15,926 - INFO -   Race 2025-12-23_82_4: 8 starts (results)
2026-01-11 00:17:16,592 - INFO -   Race 2025-12-23_82_5: 11 starts (results)
2026-01-11 00:17:17,243 - INFO -   Race 2025-12-23_82_6: 10 starts (results)
2026-01-11 00:17:17,893 - INFO -   Race 2025-12-23_82_7: 9 starts (results)
2026-01-11 00:17:17,893 - INFO - Processing track: Åby
2026-01-11 00:17:18,539 - INFO -   Race 2025-12-23_6_1: 9 starts (results)
2026-01-11 00:17:19,189 - INFO -   Race 2025-12-23_6_2: 12 starts (results)
2026-01-11 00:17:19,878 - INFO -   Race 2025-12-23_6_3: 12 starts (results)
2026-01-11 00:17:20,528 - INFO -   Race 2025-12-23_6_4: 10 starts (results)
2026-01-11 00:17:21,171 - INFO -   Race 2025-12-23_6_5: 11 starts (results)
2026-01-11 00:17:21,836 - INFO -   Race 2025-12-23_6_6: 12 starts (results)
2026-01-11 00:17:22,500 - INFO -   Race 2025-12-23_6_7: 15 starts (results)
2026-01-11 00:17:22,500 - INFO - Processing track: Happy Valley
2026-01-11 00:17:23,150 - INFO -   Race 2025-12-23_68_1: 12 starts (results)
2026-01-11 00:17:23,832 - INFO -   Race 2025-12-23_68_2: 12 starts (results)
2026-01-11 00:17:24,480 - INFO -   Race 2025-12-23_68_3: 12 starts (results)
2026-01-11 00:17:25,136 - INFO -   Race 2025-12-23_68_4: 12 starts (results)
2026-01-11 00:17:25,805 - INFO -   Race 2025-12-23_68_5: 12 starts (results)
2026-01-11 00:17:26,467 - INFO -   Race 2025-12-23_68_6: 12 starts (results)
2026-01-11 00:17:27,111 - INFO -   Race 2025-12-23_68_7: 12 starts (results)
2026-01-11 00:17:27,760 - INFO -   Race 2025-12-23_68_8: 12 starts (results)
2026-01-11 00:17:28,406 - INFO -   Race 2025-12-23_68_9: 12 starts (results)

Testing 2025-12-28
================================================================================

🎯 Winning combination: 1-9-5-4-5-5-5-9

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-3-3-2-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: PLACE on M.H. Harderthancash (126 SEK @ 48.3 odds)
  ❌ V85 Race 2: PLACE on Brenne Bruno (122 SEK @ 28.9 odds)
  ❌ V85 Race 3: WIN on Just In Time (137 SEK @ 7.4 odds)
  ❌ V85 Race 4: PLACE on Jerven Junior (128 SEK @ 11.9 odds)
  ❌ V85 Race 5: PLACE on Hickovelocissimo (117 SEK @ 3.0 odds)
  ❌ V85 Race 6: WIN on Classistile (133 SEK @ 75.8 odds)
  ✅ V85 Race 7: PLACE on Excalibur Gene (121 SEK @ 1.7 odds) → 157 SEK
  ❌ V85 Race 8: PLACE on Black Magic (116 SEK @ 101.6 odds)

Total bet: 1000 SEK
Total payout: 157 SEK
Profit: -843 SEK (-84.3% ROI)
Win rate: 1/8 (12.5%)

================================================================================
Testing 2025-12-27
================================================================================

🎯 Winning combination: 2-11-9-1-4-1-2-3

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Orion (138 SEK @ 18.6 odds)
  ❌ V85 Race 2: WIN on Hvalstad Gyda (150 SEK @ 48.9 odds)
  ✅ V85 Race 3: PLACE on Zenato (95 SEK @ 7.4 odds) → 338 SEK
  ✅ V85 Race 4: PLACE on Handfullofdollar (121 SEK @ 2.8 odds) → 209 SEK
  ❌ V85 Race 5: WIN on Ecuador Broline (127 SEK @ 6.5 odds)
  ❌ V85 Race 6: PLACE on Friska Viljan (101 SEK @ 27.9 odds)
  ❌ V85 Race 7: WIN on Spader (133 SEK @ 24.8 odds)
  ❌ V85 Race 8: WIN on Eldorado Spritz (136 SEK @ 5.9 odds)

Total bet: 1000 SEK
Total payout: 547 SEK
Profit: -453 SEK (-45.3% ROI)
Win rate: 2/8 (25.0%)

================================================================================
Testing 2025-12-26
================================================================================

🎯 Winning combination: 6-2-6-8-12-5-11-10

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Pure Atlas (125 SEK @ 9.7 odds)
  ❌ V85 Race 2: WIN on Parish Crooks V.S. (122 SEK @ 9.3 odds)
  ✅ V85 Race 3: WIN on Francesco Zet (128 SEK @ 1.3 odds) → 167 SEK
  ❌ V85 Race 4: WIN on Barkley (125 SEK @ 4.1 odds)
  ❌ V85 Race 5: WIN on Nephtys Boko (127 SEK @ 40.0 odds)
  ❌ V85 Race 6: WIN on Idle Seabrook (125 SEK @ 10.6 odds)
  ❌ V85 Race 7: WIN on Parveny (133 SEK @ 11.6 odds)
  ❌ V85 Race 8: WIN on Tactic Lane (116 SEK @ 8.4 odds)

Total bet: 1000 SEK
Total payout: 167 SEK
Profit: -833 SEK (-83.3% ROI)
Win rate: 1/8 (12.5%)

================================================================================
Testing 2025-12-25
================================================================================

🎯 Winning combination: 6-15-11-6-1-7-10-11

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Bold Silver (120 SEK @ 81.3 odds)
  ❌ V85 Race 2: WIN on Skeie Balder (117 SEK @ 4.3 odds)
  ❌ V85 Race 3: WIN on Gulangyu Island (137 SEK @ 6.2 odds)
  ❌ V85 Race 4: WIN on Bettle Hanover (150 SEK @ 15.2 odds)
  ❌ V85 Race 5: WIN on Speed Matters (119 SEK @ 5.3 odds)
  ❌ V85 Race 6: WIN on Timotejs NiceTime (129 SEK @ 6.9 odds)
  ❌ V85 Race 7: WIN on Lake's Diana (109 SEK @ 15.8 odds)
  ❌ V85 Race 8: WIN on Service Bulletin (119 SEK @ 10.0 odds)

Total bet: 1000 SEK
Total payout: 0 SEK
Profit: -1000 SEK (-100.0% ROI)
Win rate: 0/8 (0.0%)

================================================================================
Testing 2025-12-23
================================================================================

🎯 Winning combination: 2-12-4-2-8-2-5-15

================================================================================
STRATEGY 1: V85 SYSTEM BETTING (Budget: 1000 SEK)
================================================================================

Model-Driven structure: 2-2-2-2-2-3-3-3
Total combinations: 864
Cost: 864 SEK

Result: ❌ MISS

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING (Budget: 1000 SEK)
================================================================================

Placed 8 bets:
  ❌ V85 Race 1: WIN on Prince Harry (130 SEK @ 1.3 odds)
  ❌ V85 Race 2: WIN on Magna Cash (127 SEK @ 13.4 odds)
  ❌ V85 Race 3: WIN on Make My Trip V.S. (110 SEK @ 5.7 odds)
  ❌ V85 Race 4: WIN on Mellby Legacy (134 SEK @ 3.7 odds)
  ❌ V85 Race 5: WIN on Fantom Jet (123 SEK @ 2.4 odds)
  ❌ V85 Race 6: WIN on Paleo Boko (127 SEK @ 3.7 odds)
  ❌ V85 Race 7: WIN on Keep Gamble (127 SEK @ 4.6 odds)
  ❌ V85 Race 8: WIN on Lagerfeld Mo (121 SEK @ 26.7 odds)

Total bet: 1000 SEK
Total payout: 0 SEK
Profit: -1000 SEK (-100.0% ROI)
Win rate: 0/8 (0.0%)

================================================================================
COMPARISON SUMMARY
================================================================================

================================================================================
STRATEGY 1: V85 SYSTEM BETTING
================================================================================
Races won: 0/10 (0.0%)
Total invested: 8640 SEK
Average cost per race: 864 SEK

Theoretical profit (if V85 dividend per win):
     50,000 SEK:            0 SEK payout,       -8,640 SEK profit (  -100.0% ROI)
    100,000 SEK:            0 SEK payout,       -8,640 SEK profit (  -100.0% ROI)
    500,000 SEK:            0 SEK payout,       -8,640 SEK profit (  -100.0% ROI)
  1,000,000 SEK:            0 SEK payout,       -8,640 SEK profit (  -100.0% ROI)

================================================================================
STRATEGY 2: INDIVIDUAL RACE BETTING
================================================================================
Total bets: 79
Bets won: 17/79 (21.5%)
Total invested: 10000 SEK
Total payout: 19657 SEK
ACTUAL Profit: +9657 SEK (+96.6% ROI)

================================================================================
💡 RECOMMENDATION
================================================================================
Traceback (most recent call last):
  File "/home/per/Work/trav/v85_vs_individual_betting_temporal.py", line 466, in <module>
    main()
    ~~~~^^
  File "/home/per/Work/trav/v85_vs_individual_betting_temporal.py", line 462, in main
    results = comparator.run_comparison(num_races=10)
  File "/home/per/Work/trav/v85_vs_individual_betting_temporal.py", line 352, in run_comparison
    self._print_summary(all_results)
    ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/home/per/Work/trav/v85_vs_individual_betting_temporal.py", line 428, in _print_summary
    - Needs avg {breakeven_dividend:,.0f} SEK dividend to beat individual betting
                 ^^^^^^^^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'breakeven_dividend' where it is not associated with a value
